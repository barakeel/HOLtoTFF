Number: 14
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- âˆ€m n. m * n = n * m
 [] |- âˆ€n q. 0 < n â‡’ (q * n DIV n = q)
 [] |- 0 < 256
Goal: 
[Abbrev (s0 = n2s (256 * s2n s DIV 256)), r0 â‰  0, ORD c + 1 < 256,
 n2s (s2n s) = s, r0 = ORD c + 1] |- s0 = s

Number: 15
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- âˆ€n. 0 < n â‡’ âˆ€k. (k = k DIV n * n + k MOD n) âˆ§ k MOD n < n
 []
|- (0 + m = m) âˆ§ (m + 0 = m) âˆ§ (SUC m + n = SUC (m + n)) âˆ§
   (m + SUC n = SUC (m + n))
 [] |- 0 < 256
Goal: 
[Abbrev (s0 = n2s ((s2n s * 256 + ORD c + 1 âˆ’ r) DIV 256)),
 Abbrev (r = if r0 = 0 then 256 else r0), ORD c < 256, n2s (s2n s) = s,
 r0 = 0, r0 = (ORD c + 1) MOD 256] |- âˆƒq. ORD c + 1 = q * 256

Number: 16
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- âˆ€a. CHR (ORD a) = a
Goal: 
[T, Abbrev (s0 = n2s ((s2n s * 256 + ORD c + 1 âˆ’ r) DIV 256)),
 Abbrev (r = 256), ORD c < 256, n2s (s2n s) = s, q = 1, r0 = 0,
 ORD c = 255, ORD c + 1 = 256] |- c = #"\255"

Number: 17
Status: Time Out
Info: num proof 
Thm list: 
 [] |- âˆ€n q. 0 < n â‡’ (q * n DIV n = q)
 [] |- âˆ€m n. m * n = n * m
 [] |- 0 < 256
Goal: 
[ORD #"\255" < 256, n2s (s2n s) = s, ORD #"\255" = 255,
 ORD #"\255" + 1 = 256] |- n2s (256 * s2n s DIV 256) = s

Number: 20
Status: Unknown
Info: num proof 
Thm list: 
 [] |- n2s (s2n s) = s
Goal:  [] |- âˆ€s. âˆƒn. s = n2s n

Number: 27
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- âˆ€n l. n < LENGTH l â‡’ âˆ€f. EL n (MAP f l) = f (EL n l)
Goal: 
[âˆ€k'.
   ALOOKUP ls k' =
   if âˆƒy'. (k' = FST y') âˆ§ âˆƒn. n < LENGTH ls âˆ§ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, âˆ€m'. m' < m â‡’ EL m' (MAP FST ls) â‰  FST (EL n ls),
 âˆ€m. m < n'' â‡’ EL m (q::MAP FST ls) â‰  FST (EL n ls), q â‰  FST (EL n ls),
 n < m, n < LENGTH ls, EL m (MAP FST ls) = FST (EL n ls),
 EL n'' (q::MAP FST ls) = FST (EL n ls)]
|- EL m (MAP SND ls) = EL n'' (r::MAP SND ls)

Number: 28
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- âˆ€n l. n < LENGTH l â‡’ âˆ€f. EL n (MAP f l) = f (EL n l)
Goal: 
[âˆ€k'.
   ALOOKUP ls k' =
   if âˆƒy'. (k' = FST y') âˆ§ âˆƒn. n < LENGTH ls âˆ§ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, âˆ€m'. m' < m â‡’ EL m' (MAP FST ls) â‰  FST (EL n ls),
 âˆ€m. m < z â‡’ EL m (h::MAP FST ls) â‰  FST (EL n ls), Â¬(n < m),
 h â‰  FST (EL n ls), EL n (MAP FST ls) â‰  FST (EL n ls), m < LENGTH ls,
 n < LENGTH ls, SUC n < z, FST (EL m ls) = FST (EL n ls),
 EL z (h::MAP FST ls) = FST (EL n ls)]
|- SND (EL m ls) = EL z (r::MAP SND ls)

Number: 29
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- âˆ€n l. n < LENGTH l â‡’ âˆ€f. EL n (MAP f l) = f (EL n l)
Goal: 
[T,
 âˆ€k'.
   ALOOKUP ls k' =
   if âˆƒy'. (k' = FST y') âˆ§ âˆƒn. n < LENGTH ls âˆ§ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, âˆ€m'. m' < m â‡’ EL m' (MAP FST ls) â‰  FST (EL n ls),
 âˆ€m. m < SUC z â‡’ EL m (h::MAP FST ls) â‰  FST (EL n ls), Â¬(n < m),
 Â¬(n < z), h â‰  FST (EL n ls), EL m (MAP FST ls) â‰  FST (EL n ls), m < z,
 m < LENGTH ls, n < LENGTH ls, z < LENGTH ls,
 FST (EL m ls) = FST (EL n ls), FST (EL z ls) = FST (EL n ls)]
|- SND (EL m ls) = SND (EL z ls)

Number: 30
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- âˆ€n l. n < LENGTH l â‡’ âˆ€f. EL n (MAP f l) = f (EL n l)
Goal: 
[âˆ€k'.
   ALOOKUP ls k' =
   if âˆƒy'. (k' = FST y') âˆ§ âˆƒn. n < LENGTH ls âˆ§ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, âˆ€m'. m' < m â‡’ EL m' (MAP FST ls) â‰  FST (EL n ls),
 âˆ€m. m < SUC z â‡’ EL m (h::MAP FST ls) â‰  FST (EL n ls), Â¬(m < z),
 Â¬(n < m), Â¬(n < z), h â‰  FST (EL n ls), m < LENGTH ls, n < LENGTH ls,
 z < m, z < LENGTH ls, FST (EL m ls) = FST (EL n ls),
 FST (EL z ls) = FST (EL n ls)] |- SND (EL m ls) = SND (EL z ls)

Number: 40
Status: Time Out
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal:  [âˆ€k. k âˆˆ FDOM fm â‡’ FINITE {p | âˆƒft'. apply_path p (fm ' k) = SOME ft'}]
|- (âˆƒh t ft'.
      (x = h::t) âˆ§ (apply_path t (fm ' h) = SOME ft') âˆ§ h âˆˆ FDOM fm) â‡”
   âˆƒk x' ft'.
     ((x = k::x') âˆ§ (apply_path x' (fm ' k) = SOME ft')) âˆ§ k âˆˆ FDOM fm

Number: 42
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- âˆ€ft r1. relrec h ft r1 â‡’ âˆ€r2. relrec h ft r2 â‡’ (r1 = r2)
Goal: 
[âˆ€d. d âˆˆ FDOM fm â‡’ relrec h (fm ' d) (rfm ' d), FDOM rfm = FDOM fm,
 x âˆˆ FDOM fm] |- rfm ' x = @r. relrec h (fm ' x) r

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 44
Status: undefined
Info: polymorph higher-order bool num proof 
Thm list: 
 [] |- âˆ€l x. MEM x l â‡” âˆƒn. n < LENGTH l âˆ§ (x = EL n l)
Goal: 
[Abbrev (m1 = LENGTH (FILTER ($= x) l1)),
 Abbrev (m2 = LENGTH (FILTER ($= x) l2)), x' < m1, x' < m2, m1 â‰¥ m2,
 m2 â‰¥ m1]
|- MEM (EL x' (FILTER ($= x) l1)) (FILTER ($= x) l1) âˆ§
   MEM (EL x' (FILTER ($= x) l2)) (FILTER ($= x) l2)

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 45
Status: undefined
Info: higher-order bool num proof 
Thm list: 
Goal: 
[Abbrev (m1 = LENGTH (FILTER ($= x) l1)),
 Abbrev (m2 = LENGTH (FILTER ($= x) l2)), x' < m1,
 x = EL x' (FILTER ($= x) l1), x = EL x' (FILTER ($= x) l2), m1 â‰¥ m2,
 m2 â‰¥ m1, MEM (EL x' (FILTER ($= x) l1)) l1,
 MEM (EL x' (FILTER ($= x) l2)) l2]
|- EL x' (FILTER ($= x) l1) = EL x' (FILTER ($= x) l2)

Number: 47
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- dimindex (:Î±) = if FINITE ð•Œ(:Î±) then CARD ð•Œ(:Î±) else 1
Goal:  [] |- INFINITE ð•Œ(:Î±) â‡’ (dimindex (:Î±) = 1)

Number: 58
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT0A â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT0A = CARD ð•Œ(:Î±))
 [] |- FINITE IS_BIT0B â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT0B = CARD ð•Œ(:Î±))
 [] |- âˆ€n. 2 * n = n + n
Goal:  [FINITE ð•Œ(:Î±), Â¬(FINITE IS_BIT0A âˆ§ FINITE IS_BIT0B)] |- F

Number: 59
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT0A â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT0A = CARD ð•Œ(:Î±))
 [] |- FINITE IS_BIT0B â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT0B = CARD ð•Œ(:Î±))
 [] |- âˆ€n. 2 * n = n + n
Goal:  [FINITE IS_BIT0A, FINITE IS_BIT0B, INFINITE ð•Œ(:Î±)]
|- CARD (IS_BIT0A âˆª IS_BIT0B) = 1

Number: 60
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT0A â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT0A = CARD ð•Œ(:Î±))
 [] |- FINITE IS_BIT0B â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT0B = CARD ð•Œ(:Î±))
 [] |- âˆ€n. 2 * n = n + n
Goal:  [FINITE ð•Œ(:Î±), FINITE IS_BIT0A, FINITE IS_BIT0B]
|- CARD IS_BIT0A + CARD IS_BIT0B = 2 * CARD ð•Œ(:Î±)

Number: 69
Status: Parsing failed
Info: polymorph higher-order proof 
Thm list: 
 [] |- âˆ€x y. x âˆˆ {y} â‡” (x = y)
 [] |- âˆ€P x. x âˆˆ P â‡” P x
Goal:  [] |- âˆ€x. (x = BIT1C) â‡” {BIT1C} x

Number: 71
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT1A â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT1A = CARD ð•Œ(:Î±))
 [] |- (CARD IS_BIT1C = 1) âˆ§ FINITE IS_BIT1C
 [] |- FINITE IS_BIT1B â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT1B = CARD ð•Œ(:Î±))
 [] |- âˆ€n. 2 * n = n + n
Goal: 
[FINITE ð•Œ(:Î±), Â¬((FINITE IS_BIT1A âˆ§ FINITE IS_BIT1B) âˆ§ FINITE IS_BIT1C)]
|- 1 = 2 * CARD ð•Œ(:Î±) + 1

Number: 72
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT1A â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT1A = CARD ð•Œ(:Î±))
 [] |- (CARD IS_BIT1C = 1) âˆ§ FINITE IS_BIT1C
 [] |- FINITE IS_BIT1B â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT1B = CARD ð•Œ(:Î±))
 [] |- âˆ€n. 2 * n = n + n
Goal:  [FINITE IS_BIT1A, FINITE IS_BIT1B, FINITE IS_BIT1C, INFINITE ð•Œ(:Î±)]
|- CARD (IS_BIT1A âˆª IS_BIT1B âˆª IS_BIT1C) = 1

Number: 73
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT1A â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT1A = CARD ð•Œ(:Î±))
 [] |- (CARD IS_BIT1C = 1) âˆ§ FINITE IS_BIT1C
 [] |- FINITE IS_BIT1B â‡” FINITE ð•Œ(:Î±)
 [] |- FINITE ð•Œ(:Î±) â‡’ (CARD IS_BIT1B = CARD ð•Œ(:Î±))
 [] |- âˆ€n. 2 * n = n + n
Goal:  [FINITE ð•Œ(:Î±), FINITE IS_BIT1A, FINITE IS_BIT1B, FINITE IS_BIT1C]
|- CARD IS_BIT1A + CARD IS_BIT1B = 2 * CARD ð•Œ(:Î±)

Number: 74
Status: Parsing failed
Info: polymorph higher-order proof 
Thm list: 
 [] |- âˆ€x y. x âˆˆ {y} â‡” (x = y)
 [] |- âˆ€x. x âˆˆ ð•Œ(:Î±)
 [] |- âˆ€P x. x âˆˆ P â‡” P x
Goal:  [] |- ð•Œ ARB () â‡” {()} ()

Number: 75
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- dimindex (:Î±) = if FINITE ð•Œ(:Î±) then CARD ð•Œ(:Î±) else 1
 [] |- (CARD ð•Œ(:unit) = 1) âˆ§ FINITE ð•Œ(:unit)
Goal:  [] |- dimindex (:unit) = 1

Number: 76
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- dimword (:Î±) = 2 ** dimindex (:Î±)
 [] |- 0 < dimindex (:Î±)
 [] |- (âˆ€m. m ** 0 = 1) âˆ§ âˆ€m n. m ** SUC n = m * m ** n
 [] |- âˆ€b. 1 < b â‡’ âˆ€n m. b ** m < b ** n â‡” m < n
 [] |- 1 < 2
Goal:  [] |- 1 < dimword (:Î±)

Number: 77
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- (âˆ€m. m ** 0 = 1) âˆ§ âˆ€m n. m ** SUC n = m * m ** n
 [] |- âˆ€a b c. a â‰¤ b âˆ§ c < b â‡’ a + c < 2 * b
Goal:  [âˆ€f. SUM n (Î»i. SBIT (f i) i) < 2 ** n, SBIT (f n) n â‰¤ 2 ** n]
|- SBIT (f n) n + SUM n (Î»i. SBIT (f i) i) < 2 ** SUC n

Number: 78
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- âˆ€n f. SUM n (Î»i. SBIT (f i) i) < 2 ** n
Goal:  [n â‰¤ i, BIT i (SUM n (Î»j. SBIT (f j) j)) â‡” f i âˆ§ i < n]
|- SUM n (Î»i. SBIT (f i) i) < 2 ** n

Number: 82
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- âˆ€n. 0 < n â‡’ âˆ€k. (k = k DIV n * n + k MOD n) âˆ§ k MOD n < n
Goal:  [Abbrev (WL = dimword (:Î±)), 0 < WL, WL = 2 * INT_MIN (:Î±)]
|- (n = n DIV WL * WL + n MOD WL) âˆ§ n MOD WL < WL

Number: 83
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- âˆ€n r. r < n â‡’ âˆ€q. (q * n + r) DIV n = q
 [] |- âˆ€m n. m * n = n * m
 [] |- âˆ€m n p. m * (n * p) = m * n * p
Goal: 
[Abbrev (q = (q * (2 * INT_MIN (:Î±)) + r) DIV (2 * INT_MIN (:Î±))),
 Abbrev (r = (q * (2 * INT_MIN (:Î±)) + r) MOD (2 * INT_MIN (:Î±))),
 Abbrev (2 * INT_MIN (:Î±) = dimword (:Î±)), Â¬(INT_MIN (:Î±) â‰¤ r),
 r < INT_MIN (:Î±), r < 2 * INT_MIN (:Î±), 0 < 2 * INT_MIN (:Î±),
 ((q * (2 * INT_MIN (:Î±)) + r) DIV 2 ** (dimindex (:Î±) âˆ’ 1)) MOD 2 = 1]
|- (q * (2 * INT_MIN (:Î±)) + r) DIV INT_MIN (:Î±) = 2 * q

Number: 84
Status: Time Out
Info: polymorph bool num proof 
Thm list: 
 [] |- 0 â‰  1 âˆ§ 0 < 2
 [] |- âˆ€n. 0 < n â‡’ âˆ€k. (k * n) MOD n = 0
 [] |- âˆ€m n. m * n = n * m
 [] |- INT_MIN (:Î±) = 2 ** (dimindex (:Î±) âˆ’ 1)
Goal: 
[Abbrev (WL = dimword (:Î±)), Abbrev (q = n DIV WL),
 Abbrev (r = n MOD WL), Â¬(INT_MIN (:Î±) â‰¤ r), r < WL, r < INT_MIN (:Î±),
 0 < WL, WL = 2 * INT_MIN (:Î±), n = q * WL + r,
 n DIV INT_MIN (:Î±) = 2 * q,
 ((q * (2 * INT_MIN (:Î±)) + r) DIV 2 ** (dimindex (:Î±) âˆ’ 1)) MOD 2 = 1]
|- F

Number: 85
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- âˆ€a b n.
     Â¬BIT n a âˆ¨ Â¬BIT n b â‡’
     (SBIT (BIT n a âˆ¨ BIT n b) n = SBIT (BIT n a) n + SBIT (BIT n b) n)
 [] |- n < SUC n
Goal: 
[âˆ€a b.
   (âˆ€i. i < n â‡’ Â¬BIT i a âˆ¨ Â¬BIT i b) â‡’
   (SUM n (Î»i. SBIT (BIT i a) i) + SUM n (Î»i. SBIT (BIT i b) i) =
    BITWISE n $\/ a b), âˆ€i. i < SUC n â‡’ Â¬BIT i a âˆ¨ Â¬BIT i b]
|- SBIT (BIT n a) n + SBIT (BIT n b) n + BITWISE n $\/ a b =
   SBIT (BIT n a âˆ¨ BIT n b) n + BITWISE n $\/ a b

Number: 86
Status: 
Info: polymorph proof 
Thm list: 
 []
|- âˆ€w.
     Â¬(dimindex (:Î²) < dimindex (:Î±) âˆ§ dimindex (:Î²) < dimindex (:Î³)) â‡’
     (sw2sw (sw2sw w) = sw2sw w)
Goal:  [Â¬(dimindex (:Î²) < dimindex (:Î±) âˆ§ dimindex (:Î²) < dimindex (:Î³))]
|- sw2sw (sw2sw w) = sw2sw w

Number: 87
Status: Parsing failed
Info: num proof 
Thm list: 
 [] |- âˆ€m n. n < m â‡’ âˆƒp. m = n + (p + 1)
 [] |- âˆ€m. SUC m = m + 1
 [] |- (âˆ€n. 0 + n = n) âˆ§ âˆ€m n. SUC m + n = SUC (m + n)
Goal: 
[T, i < dimindex (:Î±), 0 < dimindex (:Î±) âˆ’ l, l â‰¤ dimindex (:Î±) âˆ’ 1,
 dimindex (:Î±) â‰¤ SUC h] |- âˆƒx. dimindex (:Î±) âˆ’ l = SUC x

Number: 99
Status: Unknown
Info: num proof 
Thm list: 
 [] |- âˆ€b n. n â‰  0 âˆ§ n < 2 ** b â‡’ âˆƒi. i < b âˆ§ BIT i n
Goal:  [n â‰  0, n < 2 ** dimindex (:Î±)] |- âˆƒi. i < dimindex (:Î±) âˆ§ BIT i n

Number: 135
Status: Time Out
Info: polymorph proof 
Thm list: 
 [] |- âˆ€w. -w + w = 0w
 [] |- âˆ€w. w + -w = 0w
 [] |- (âˆ€w. w + 0w = w) âˆ§ âˆ€w. 0w + w = w
 [] |- âˆ€v w x. v + (w + x) = v + w + x
 [] |- âˆ€v w. v + w = w + v
Goal:  [] |- -a + -1w + b + 1w = b + -a

Number: 142
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal:  [FINITE {n2w n | n < k}, n < k, x = n2w n, {n2w n' | F} = âˆ…]
|- âˆƒn'. (n2w n = n2w n') âˆ§ (n' < k âˆ¨ (n' = k))

Number: 143
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal:  [FINITE {n2w n | n < k}, x = n2w k, {n2w n | F} = âˆ…]
|- âˆƒn. (n2w k = n2w n) âˆ§ (n < k âˆ¨ (n = k))

Number: 144
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal:  [FINITE {n2w n | n < k}, n < k, x = n2w n, {n2w n' | F} = âˆ…]
|- (n2w n = n2w k) âˆ¨ âˆƒn'. (n2w n = n2w n') âˆ§ n' < k

Number: 154
Status: Time Out
Info: num proof 
Thm list: 
 [] |- âˆ€m n. Â¬(m < n) â‡” n â‰¤ m
 [] |- âˆ€n p. 2 ** p â‰¤ n âˆ§ n < 2 ** SUC p â‡’ (LOG2 n = p)
 [] |- âˆ€n. n â‰  0 â‡’ BIT (LOG2 n) n
Goal: 
[BITS n 0 x + BITS n 0 y + 1 â‰  0, BITS n 0 x + BITS n 0 y â‰  0,
 Â¬BIT (SUC n) x, Â¬BIT (SUC n) (BITS n 0 x + BITS n 0 y + 1),
 BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC (SUC n),
 BITS n 0 x < 2 ** SUC n, BITS n 0 y < 2 ** SUC n, BIT (SUC n) y]
|- BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC n

Number: 155
Status: Time Out
Info: num proof 
Thm list: 
 [] |- âˆ€m n. Â¬(m < n) â‡” n â‰¤ m
 [] |- âˆ€n p. 2 ** p â‰¤ n âˆ§ n < 2 ** SUC p â‡’ (LOG2 n = p)
 [] |- âˆ€n. n â‰  0 â‡’ BIT (LOG2 n) n
Goal: 
[BITS n 0 x + BITS n 0 y + 1 â‰  0, BITS n 0 x + BITS n 0 y â‰  0,
 Â¬BIT (SUC n) y, Â¬BIT (SUC n) (BITS n 0 x + BITS n 0 y + 1),
 BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC (SUC n),
 BITS n 0 x < 2 ** SUC n, BITS n 0 y < 2 ** SUC n, BIT (SUC n) x]
|- BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC n

Number: 156
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- âˆ€n a b.
     BIT (SUC n) (a + b) â‡”
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
       BIT (SUC n) a â‡” BIT (SUC n) b
     else BIT (SUC n) a â‡Ž BIT (SUC n) b
 []
|- âˆ€n a b.
     BIT (SUC n) (a + b + 1) â‡”
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b + 1) then
       BIT (SUC n) a â‡” BIT (SUC n) b
     else BIT (SUC n) a â‡Ž BIT (SUC n) b
Goal: 
[âˆ€x y c.
   BSUM i (Î»i. BIT i x) (Î»i. BIT i y) c â‡”
   BIT i (x + y + if c then 1 else 0)]
|- ((BIT (SUC i) x â‡” Â¬BIT (SUC i) y) â‡”
    Â¬BIT (SUC i) (BITS i 0 x + BITS i 0 y)) â‡” BIT (SUC i) (x + y)

Number: 157
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- âˆ€n a b.
     BIT (SUC n) (a + b) â‡”
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
       BIT (SUC n) a â‡” BIT (SUC n) b
     else BIT (SUC n) a â‡Ž BIT (SUC n) b
 []
|- âˆ€n a b.
     BIT (SUC n) (a + b + 1) â‡”
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b + 1) then
       BIT (SUC n) a â‡” BIT (SUC n) b
     else BIT (SUC n) a â‡Ž BIT (SUC n) b
Goal: 
[âˆ€x y c.
   BSUM i (Î»i. BIT i x) (Î»i. BIT i y) c â‡”
   BIT i (x + y + if c then 1 else 0)]
|- ((BIT (SUC i) x â‡” Â¬BIT (SUC i) y) â‡”
    Â¬BIT (SUC i) (BITS i 0 x + BITS i 0 y + 1)) â‡”
   BIT (SUC i) (x + y + 1)

Number: 158
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[âˆ€P f.
   (âˆ€j. j < n â‡’ Â¬P j) â‡’
   (FOLDL (Î»a j. a âˆ¨ P j âˆ§ f j) F (COUNT_LIST n) â‡” F), âˆ€j. j < n â‡’ Â¬P j,
 âˆ€j. j < SUC n â‡’ Â¬P j] |- Â¬FOLDL (Î»a j. a âˆ¨ P j âˆ§ f j) F (COUNT_LIST n)

Number: 159
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[P i,
 âˆ€f P i.
   i < n âˆ§ P i âˆ§ (âˆ€i j. P i âˆ§ P j âˆ§ i < n âˆ§ j < n â‡’ (i = j)) â‡’
   (FOLDL (Î»a j. a âˆ¨ P j âˆ§ f j) F (COUNT_LIST n) â‡” f i),
 âˆ€i j. P i âˆ§ P j âˆ§ i < n âˆ§ j < n â‡’ (i = j),
 âˆ€i j. P i âˆ§ P j âˆ§ i < SUC n âˆ§ j < SUC n â‡’ (i = j), i < n, i < SUC n]
|- FOLDL (Î»a j. a âˆ¨ P j âˆ§ f j) F (COUNT_LIST n) â‡” f i

Number: 160
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[P i,
 âˆ€f P i.
   i < n âˆ§ P i âˆ§ (âˆ€i j. P i âˆ§ P j âˆ§ i < n âˆ§ j < n â‡’ (i = j)) â‡’
   (FOLDL (Î»a j. a âˆ¨ P j âˆ§ f j) F (COUNT_LIST n) â‡” f i),
 âˆ€i j. P i âˆ§ P j âˆ§ i < n âˆ§ j < n â‡’ (i = j), i < n, i < SUC n,
 FOLDL (Î»a j. a âˆ¨ P j âˆ§ f j) F (COUNT_LIST n) â‡” f i, P n â‡’ (n = i)]
|- f i âˆ¨ P n âˆ§ f n â‡” f i

Number: 164
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- âˆ€m. m â‰¤ m
 []
|- âˆ€P n m.
     1 < n âˆ§ n â‰¤ dimindex (:Î±) â‡’
     (FOLDL (Î»a j. a âˆ¨ (m = n2w j) âˆ§ P j) F (COUNT_LIST n) â‡”
      FOLDL (Î»a j. a âˆ¨ ((LOG2 (n âˆ’ 1) -- 0) m = n2w j) âˆ§ P j) F
        (COUNT_LIST n) âˆ§
      ((dimindex (:Î±) âˆ’ 1 -- LOG2 (n âˆ’ 1) + 1) m = 0w))
Goal:  [dimindex (:Î±) â‰  1, i < dimindex (:Î±), 1 < dimindex (:Î±)]
|- FOLDL (Î»a j. a âˆ¨ (m = n2w j) âˆ§ j â‰¤ i âˆ§ w ' (i âˆ’ j)) F
     (COUNT_LIST (dimindex (:Î±))) â‡”
   FOLDL
     (Î»a j.
        a âˆ¨
        ((LOG2 (dimindex (:Î±) âˆ’ 1) -- 0) m = n2w j) âˆ§ j â‰¤ i âˆ§
        w ' (i âˆ’ j)) F (COUNT_LIST (dimindex (:Î±))) âˆ§
   ((dimindex (:Î±) âˆ’ 1 -- LOG2 (dimindex (:Î±) âˆ’ 1) + 1) m = 0w)

Number: 165
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- âˆ€m. m â‰¤ m
 []
|- âˆ€P n m.
     1 < n âˆ§ n â‰¤ dimindex (:Î±) â‡’
     (FOLDL (Î»a j. a âˆ¨ (m = n2w j) âˆ§ P j) F (COUNT_LIST n) â‡”
      FOLDL (Î»a j. a âˆ¨ ((LOG2 (n âˆ’ 1) -- 0) m = n2w j) âˆ§ P j) F
        (COUNT_LIST n) âˆ§
      ((dimindex (:Î±) âˆ’ 1 -- LOG2 (n âˆ’ 1) + 1) m = 0w))
Goal:  [dimindex (:Î±) â‰  1, i < dimindex (:Î±), 1 < dimindex (:Î±)]
|- FOLDL (Î»a j. a âˆ¨ (m = n2w j) âˆ§ i + j < dimindex (:Î±) âˆ§ w ' (i + j)) F
     (COUNT_LIST (dimindex (:Î±))) â‡”
   FOLDL
     (Î»a j.
        a âˆ¨
        ((LOG2 (dimindex (:Î±) âˆ’ 1) -- 0) m = n2w j) âˆ§
        i + j < dimindex (:Î±) âˆ§ w ' (i + j)) F
     (COUNT_LIST (dimindex (:Î±))) âˆ§
   ((dimindex (:Î±) âˆ’ 1 -- LOG2 (dimindex (:Î±) âˆ’ 1) + 1) m = 0w)

Number: 166
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- âˆ€m. m â‰¤ m
 []
|- âˆ€P n m.
     1 < n âˆ§ n â‰¤ dimindex (:Î±) â‡’
     (FOLDL (Î»a j. a âˆ¨ (m = n2w j) âˆ§ P j) F (COUNT_LIST n) â‡”
      FOLDL (Î»a j. a âˆ¨ ((LOG2 (n âˆ’ 1) -- 0) m = n2w j) âˆ§ P j) F
        (COUNT_LIST n) âˆ§
      ((dimindex (:Î±) âˆ’ 1 -- LOG2 (n âˆ’ 1) + 1) m = 0w))
Goal:  [dimindex (:Î±) â‰  1, i < dimindex (:Î±), 1 < dimindex (:Î±)]
|- FOLDL (Î»a j. a âˆ¨ (m = n2w j) âˆ§ (w â‰« j) ' i) F
     (COUNT_LIST (dimindex (:Î±))) âˆ¨
   n2w (dimindex (:Î±) âˆ’ 1) <â‚Š m âˆ§ word_msb w â‡”
   FOLDL
     (Î»a j.
        a âˆ¨ ((LOG2 (dimindex (:Î±) âˆ’ 1) -- 0) m = n2w j) âˆ§ (w â‰« j) ' i) F
     (COUNT_LIST (dimindex (:Î±))) âˆ§
   ((dimindex (:Î±) âˆ’ 1 -- LOG2 (dimindex (:Î±) âˆ’ 1) + 1) m = 0w) âˆ¨
   n2w (dimindex (:Î±) âˆ’ 1) <â‚Š m âˆ§ word_msb w

Number: 168
Status: Time Out
Info: num proof 
Thm list: 
 [] |- k â‰  0 â‡’ (j % k % k = j % k)
 [] |- k â‰  0 â‡’ ((i % k âˆ’ j % k) % k = (i âˆ’ j) % k)
Goal: 
[&(2 * INT_MIN (:Î±)) â‰  0, n â‰  0, 0 < dimword (:Î±),
 n MOD (2 * INT_MIN (:Î±)) < 2 * INT_MIN (:Î±), 1 â‰¤ INT_MIN (:Î±),
 1 â‰¤ dimword (:Î±), i = -&n, dimword (:Î±) = 2 * INT_MIN (:Î±), i < 0]
|- (&(2 * INT_MIN (:Î±)) âˆ’ &n) % &(2 * INT_MIN (:Î±)) =
   (&(2 * INT_MIN (:Î±)) âˆ’ &n % &(2 * INT_MIN (:Î±))) %
   &(2 * INT_MIN (:Î±))

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- âˆ€i.
     INT_MIN (:Î±) â‰¤ i âˆ§ i < 0 âˆ§ dimindex (:Î±) â‰¤ dimindex (:Î²) â‡’
     âˆƒn.
       INT_MIN (:Î±) â‰¤ n âˆ§ n < dimword (:Î±) âˆ§ (-n2w (Num (-i)) = n2w n) âˆ§
       (-n2w (Num (-i)) =
        n2w (2 ** dimindex (:Î²) âˆ’ 2 ** dimindex (:Î±) + n))
Number: 174
Status: undefined
Info: polymorph 
Thm list: 
 []
|- âˆ€i.
     INT_MIN (:Î±) â‰¤ i âˆ§ i < 0 âˆ§ dimindex (:Î±) â‰¤ dimindex (:Î²) â‡’
     âˆƒn.
       INT_MIN (:Î±) â‰¤ n âˆ§ n < dimword (:Î±) âˆ§ (-n2w (Num (-i)) = n2w n) âˆ§
       (-n2w (Num (-i)) =
        n2w (2 ** dimindex (:Î²) âˆ’ 2 ** dimindex (:Î±) + n))
Goal: 
[i < dimindex (:Î±), dimindex (:Î²) â‰¤ dimindex (:Î±), j â‰¤ INT_MAX (:Î²),
 INT_MIN (:Î²) â‰¤ j, j < 0]
|- âˆƒn.
     INT_MIN (:Î²) â‰¤ n âˆ§ n < dimword (:Î²) âˆ§ (-n2w (Num (-j)) = n2w n) âˆ§
     (-n2w (Num (-j)) =
      n2w (2 ** dimindex (:Î±) âˆ’ 2 ** dimindex (:Î²) + n))

Number: 193
Status: Parsing failed
Info: num proof 
Thm list: 
Goal: 
[n â‰  0, n â‰  UINT_MAX (:Î±),
 UINT_MAX (:Î±) â‰¤ n âˆ§ n â‰  UINT_MAX (:Î±) â‡” dimword (:Î±) â‰¤ n]
|- (if UINT_MAX (:Î±) â‰¤ n then n2w (UINT_MAX (:Î±)) else n2w n) =
   if dimword (:Î±) â‰¤ n then n2w (UINT_MAX (:Î±)) else n2w n

Number: 206
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- âˆ€f. âˆƒg. âˆ€x. g x = case f x of NONE => [||] | SOME (a,b) => b:::g a
Goal:  []
|- âˆƒLUNFOLD.
     âˆ€f x.
       LUNFOLD f x =
       case f x of NONE => [||] | SOME (v1,v2) => v2:::LUNFOLD f v1

structure: tactic - tactic - conv function: BEAGLE_CONV_TAC - NUM_CONV_TAC - num_conv message:  -  - abstraction
Number: 207
Status: undefined
Info: lambda-lift 
Thm list: 
Goal: 
[âˆ€l1 l2. (if R l1 l2 then l1 else [||]) = if R l1 l2 then l2 else [||],
 âˆ€ll3 ll4.
   R ll3 ll4 â‡’
   (ll3 = [||]) âˆ§ (ll4 = [||]) âˆ¨
   âˆƒh t1 t2. (ll3 = h:::t1) âˆ§ (ll4 = h:::t2) âˆ§ R t1 t2, R ll1 ll2,
 (âˆ€x.
    (Î»(l1,l2). if R l1 l2 then l1 else [||]) x =
    case
      (Î»(l1,l2).
         if R l1 l2 then
           case LHD l1 of
             NONE => NONE
           | SOME h => SOME ((THE (LTL l1),THE (LTL l2)),h)
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::(Î»(l1,l2). if R l1 l2 then l1 else [||]) a) âˆ§
 (âˆ€x.
    (Î»(l1,l2). if R l1 l2 then l2 else [||]) x =
    case
      (Î»(l1,l2).
         if R l1 l2 then
           case LHD l1 of
             NONE => NONE
           | SOME h => SOME ((THE (LTL l1),THE (LTL l2)),h)
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::(Î»(l1,l2). if R l1 l2 then l2 else [||]) a) â‡’
 ((Î»(l1,l2). if R l1 l2 then l1 else [||]) =
  (Î»(l1,l2). if R l1 l2 then l2 else [||]))] |- ll1 = ll2

Number: 214
Status: Unknown
Info: polymorph num proof 
Thm list: 
 []
|- llength_rel [||] 0 âˆ§
   âˆ€h n t. llength_rel t n â‡’ llength_rel (h:::t) (SUC n)
Goal:  [llength_rel t n] |- âˆƒn. llength_rel (h:::t) n

Number: 217
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- âˆ€t. LFINITE t â‡’ âˆƒn. llength_rel t n
Goal:  [LFINITE t] |- âˆƒn. llength_rel t n

Number: 224
Status: Unknown
Info: higher-order num proof 
Thm list: 
Goal:  []
|- (âˆ€ll. exists P ll â‡’ âˆƒn a t. (LDROP n ll = SOME (a:::t)) âˆ§ P a) â‡’
   exists P ll â‡’
   âˆƒn a t. (LDROP n ll = SOME (a:::t)) âˆ§ P a

Number: 228
Status: Unknown
Info: num proof 
Thm list: 
 [] |- âˆ€m. (m = 0) âˆ¨ âˆƒn. m = SUC n
Goal: 
[P n, P p, P (SUC n'), âˆ€m. m < n' â‡’ Â¬P (SUC m), âˆ€m. m < p â‡’ Â¬P m, Â¬P 0,
 Â¬(SUC n' < p), p < SUC n'] |- âˆƒp0. p = SUC p0

Number: 230
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- âˆ€l. (l = [||]) âˆ¨ âˆƒh t. l = h:::t
 [] |- (exists P [||] â‡” F) âˆ§ (exists P (h:::t) â‡” P h âˆ¨ exists P t)
Goal: 
[âˆ€x.
   (case
      (Î»ll.
         if exists P ll then
           (let n = LEAST n. âˆƒe. (SOME e = LNTH n ll) âˆ§ P e
            in
              SOME (THE (LDROP (SUC n) ll),THE (LNTH n ll)))
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, Abbrev (n = LEAST n. âˆƒe. (SOME e = LNTH n ll) âˆ§ P e),
 Â¬P (THE (LHD ll)), exists P ll] |- âˆƒh t. ll = h:::t

Number: 231
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- âˆ€l. (l = [||]) âˆ¨ âˆƒh t. l = h:::t
 [] |- (exists P [||] â‡” F) âˆ§ (exists P (h:::t) â‡” P h âˆ¨ exists P t)
Goal: 
[P (THE (LHD ll)),
 âˆ€x.
   (case
      (Î»ll.
         if exists P ll then
           (let n = LEAST n. âˆƒe. (SOME e = LNTH n ll) âˆ§ P e
            in
              SOME (THE (LDROP (SUC n) ll),THE (LNTH n ll)))
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, Abbrev (n = LEAST n. âˆƒe. (SOME e = LNTH n ll) âˆ§ P e),
 exists P ll] |- âˆƒh t. ll = h:::t

Number: 232
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- âˆ€l. exists P l â‡” âˆƒn e. (SOME e = LNTH n l) âˆ§ P e
Goal: 
[âˆ€x.
   (case
      if exists P x then
        (let n = LEAST n. âˆƒe. (SOME e = LNTH n x) âˆ§ P e
         in
           SOME (THE (LDROP (SUC n) x),THE (LNTH n x)))
      else NONE
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, Â¬P h, exists P t] |- âˆƒm e. (SOME e = LNTH m t) âˆ§ P e

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (âˆ€n. LNTH n [||] = NONE) âˆ§ (âˆ€h t. LNTH 0 (h:::t) = SOME h) âˆ§
   âˆ€n h t. LNTH (SUC n) (h:::t) = LNTH n t
Number: 233
Status: undefined
Info: polymorph 
Thm list: 
 [] |- âˆ€x y. (SOME x = SOME y) â‡” (x = y)
 []
|- (âˆ€n. LNTH n [||] = NONE) âˆ§ (âˆ€h t. LNTH 0 (h:::t) = SOME h) âˆ§
   âˆ€n h t. LNTH (SUC n) (h:::t) = LNTH n t
Goal: 
[P e, P h,
 âˆ€x.
   (case
      if exists P x then
        (let n = LEAST n. âˆƒe. (SOME e = LNTH n x) âˆ§ P e
         in
           SOME (THE (LDROP (SUC n) x),THE (LNTH n x)))
      else NONE
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, âˆ€m. m < n â‡’ âˆ€e. SOME e â‰  LNTH m (h:::t) âˆ¨ Â¬P e, n â‰  0, 0 < n,
 SOME e = LNTH n (h:::t)] |- F

structure: tactic - tactic - conv function: BEAGLE_CONV_TAC - NUM_CONV_TAC - num_conv message:  -  - abstraction
Number: 234
Status: undefined
Info: polymorph lambda-lift 
Thm list: 
 [] |- âˆ€l. (l = [||]) âˆ¨ âˆƒh t. l = h:::t
 [] |- (every P [||] â‡” T) âˆ§ (every P (h:::t) â‡” P h âˆ§ every P t)
Goal: 
[âˆ€x.
   LHD (g x) =
   OPTION_MAP SND
     ((Î»ll.
         if every ($= [||]) ll then NONE
         else
           (let n = LEAST n. âˆƒe. (SOME e = LNTH n ll) âˆ§ e â‰  [||] in
            let nlist = THE (LNTH n ll)
            in
              SOME
                (THE (LTL nlist):::THE (LDROP (SUC n) ll),
                 THE (LHD nlist)))) x),
 âˆ€x.
   LTL (g x) =
   OPTION_MAP (g o FST)
     ((Î»ll.
         if every ($= [||]) ll then NONE
         else
           (let n = LEAST n. âˆƒe. (SOME e = LNTH n ll) âˆ§ e â‰  [||] in
            let nlist = THE (LNTH n ll)
            in
              SOME
                (THE (LTL nlist):::THE (LDROP (SUC n) ll),
                 THE (LHD nlist)))) x), Â¬every ($= [||]) ll]
|- âˆƒh t. ll = h:::t

