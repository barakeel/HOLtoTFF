Number: 14
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- ∀m n. m * n = n * m
 [] |- ∀n q. 0 < n ⇒ (q * n DIV n = q)
 [] |- 0 < 256
Goal: 
[Abbrev (s0 = n2s (256 * s2n s DIV 256)), r0 ≠ 0, ORD c + 1 < 256,
 n2s (s2n s) = s, r0 = ORD c + 1] |- s0 = s

Number: 15
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- ∀n. 0 < n ⇒ ∀k. (k = k DIV n * n + k MOD n) ∧ k MOD n < n
 []
|- (0 + m = m) ∧ (m + 0 = m) ∧ (SUC m + n = SUC (m + n)) ∧
   (m + SUC n = SUC (m + n))
 [] |- 0 < 256
Goal: 
[Abbrev (s0 = n2s ((s2n s * 256 + ORD c + 1 − r) DIV 256)),
 Abbrev (r = if r0 = 0 then 256 else r0), ORD c < 256, n2s (s2n s) = s,
 r0 = 0, r0 = (ORD c + 1) MOD 256] |- ∃q. ORD c + 1 = q * 256

Number: 16
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- ∀a. CHR (ORD a) = a
Goal: 
[T, Abbrev (s0 = n2s ((s2n s * 256 + ORD c + 1 − r) DIV 256)),
 Abbrev (r = 256), ORD c < 256, n2s (s2n s) = s, q = 1, r0 = 0,
 ORD c = 255, ORD c + 1 = 256] |- c = #"\255"

Number: 17
Status: Time Out
Info: num proof 
Thm list: 
 [] |- ∀n q. 0 < n ⇒ (q * n DIV n = q)
 [] |- ∀m n. m * n = n * m
 [] |- 0 < 256
Goal: 
[ORD #"\255" < 256, n2s (s2n s) = s, ORD #"\255" = 255,
 ORD #"\255" + 1 = 256] |- n2s (256 * s2n s DIV 256) = s

Number: 20
Status: Unknown
Info: num proof 
Thm list: 
 [] |- n2s (s2n s) = s
Goal:  [] |- ∀s. ∃n. s = n2s n

Number: 27
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
Goal: 
[∀k'.
   ALOOKUP ls k' =
   if ∃y'. (k' = FST y') ∧ ∃n. n < LENGTH ls ∧ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, ∀m'. m' < m ⇒ EL m' (MAP FST ls) ≠ FST (EL n ls),
 ∀m. m < n'' ⇒ EL m (q::MAP FST ls) ≠ FST (EL n ls), q ≠ FST (EL n ls),
 n < m, n < LENGTH ls, EL m (MAP FST ls) = FST (EL n ls),
 EL n'' (q::MAP FST ls) = FST (EL n ls)]
|- EL m (MAP SND ls) = EL n'' (r::MAP SND ls)

Number: 28
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
Goal: 
[∀k'.
   ALOOKUP ls k' =
   if ∃y'. (k' = FST y') ∧ ∃n. n < LENGTH ls ∧ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, ∀m'. m' < m ⇒ EL m' (MAP FST ls) ≠ FST (EL n ls),
 ∀m. m < z ⇒ EL m (h::MAP FST ls) ≠ FST (EL n ls), ¬(n < m),
 h ≠ FST (EL n ls), EL n (MAP FST ls) ≠ FST (EL n ls), m < LENGTH ls,
 n < LENGTH ls, SUC n < z, FST (EL m ls) = FST (EL n ls),
 EL z (h::MAP FST ls) = FST (EL n ls)]
|- SND (EL m ls) = EL z (r::MAP SND ls)

Number: 29
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
Goal: 
[T,
 ∀k'.
   ALOOKUP ls k' =
   if ∃y'. (k' = FST y') ∧ ∃n. n < LENGTH ls ∧ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, ∀m'. m' < m ⇒ EL m' (MAP FST ls) ≠ FST (EL n ls),
 ∀m. m < SUC z ⇒ EL m (h::MAP FST ls) ≠ FST (EL n ls), ¬(n < m),
 ¬(n < z), h ≠ FST (EL n ls), EL m (MAP FST ls) ≠ FST (EL n ls), m < z,
 m < LENGTH ls, n < LENGTH ls, z < LENGTH ls,
 FST (EL m ls) = FST (EL n ls), FST (EL z ls) = FST (EL n ls)]
|- SND (EL m ls) = SND (EL z ls)

Number: 30
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n l. n < LENGTH l ⇒ ∀f. EL n (MAP f l) = f (EL n l)
Goal: 
[∀k'.
   ALOOKUP ls k' =
   if ∃y'. (k' = FST y') ∧ ∃n. n < LENGTH ls ∧ (y' = EL n ls) then
     SOME (EL (LEAST n. EL n (MAP FST ls) = k') (MAP SND ls))
   else NONE, ∀m'. m' < m ⇒ EL m' (MAP FST ls) ≠ FST (EL n ls),
 ∀m. m < SUC z ⇒ EL m (h::MAP FST ls) ≠ FST (EL n ls), ¬(m < z),
 ¬(n < m), ¬(n < z), h ≠ FST (EL n ls), m < LENGTH ls, n < LENGTH ls,
 z < m, z < LENGTH ls, FST (EL m ls) = FST (EL n ls),
 FST (EL z ls) = FST (EL n ls)] |- SND (EL m ls) = SND (EL z ls)

Number: 40
Status: Time Out
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal:  [∀k. k ∈ FDOM fm ⇒ FINITE {p | ∃ft'. apply_path p (fm ' k) = SOME ft'}]
|- (∃h t ft'.
      (x = h::t) ∧ (apply_path t (fm ' h) = SOME ft') ∧ h ∈ FDOM fm) ⇔
   ∃k x' ft'.
     ((x = k::x') ∧ (apply_path x' (fm ' k) = SOME ft')) ∧ k ∈ FDOM fm

Number: 42
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀ft r1. relrec h ft r1 ⇒ ∀r2. relrec h ft r2 ⇒ (r1 = r2)
Goal: 
[∀d. d ∈ FDOM fm ⇒ relrec h (fm ' d) (rfm ' d), FDOM rfm = FDOM fm,
 x ∈ FDOM fm] |- rfm ' x = @r. relrec h (fm ' x) r

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 44
Status: undefined
Info: polymorph higher-order bool num proof 
Thm list: 
 [] |- ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l)
Goal: 
[Abbrev (m1 = LENGTH (FILTER ($= x) l1)),
 Abbrev (m2 = LENGTH (FILTER ($= x) l2)), x' < m1, x' < m2, m1 ≥ m2,
 m2 ≥ m1]
|- MEM (EL x' (FILTER ($= x) l1)) (FILTER ($= x) l1) ∧
   MEM (EL x' (FILTER ($= x) l2)) (FILTER ($= x) l2)

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 45
Status: undefined
Info: higher-order bool num proof 
Thm list: 
Goal: 
[Abbrev (m1 = LENGTH (FILTER ($= x) l1)),
 Abbrev (m2 = LENGTH (FILTER ($= x) l2)), x' < m1,
 x = EL x' (FILTER ($= x) l1), x = EL x' (FILTER ($= x) l2), m1 ≥ m2,
 m2 ≥ m1, MEM (EL x' (FILTER ($= x) l1)) l1,
 MEM (EL x' (FILTER ($= x) l2)) l2]
|- EL x' (FILTER ($= x) l1) = EL x' (FILTER ($= x) l2)

Number: 47
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- dimindex (:α) = if FINITE 𝕌(:α) then CARD 𝕌(:α) else 1
Goal:  [] |- INFINITE 𝕌(:α) ⇒ (dimindex (:α) = 1)

Number: 58
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT0A ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT0A = CARD 𝕌(:α))
 [] |- FINITE IS_BIT0B ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT0B = CARD 𝕌(:α))
 [] |- ∀n. 2 * n = n + n
Goal:  [FINITE 𝕌(:α), ¬(FINITE IS_BIT0A ∧ FINITE IS_BIT0B)] |- F

Number: 59
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT0A ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT0A = CARD 𝕌(:α))
 [] |- FINITE IS_BIT0B ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT0B = CARD 𝕌(:α))
 [] |- ∀n. 2 * n = n + n
Goal:  [FINITE IS_BIT0A, FINITE IS_BIT0B, INFINITE 𝕌(:α)]
|- CARD (IS_BIT0A ∪ IS_BIT0B) = 1

Number: 60
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT0A ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT0A = CARD 𝕌(:α))
 [] |- FINITE IS_BIT0B ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT0B = CARD 𝕌(:α))
 [] |- ∀n. 2 * n = n + n
Goal:  [FINITE 𝕌(:α), FINITE IS_BIT0A, FINITE IS_BIT0B]
|- CARD IS_BIT0A + CARD IS_BIT0B = 2 * CARD 𝕌(:α)

Number: 69
Status: Parsing failed
Info: polymorph higher-order proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
 [] |- ∀P x. x ∈ P ⇔ P x
Goal:  [] |- ∀x. (x = BIT1C) ⇔ {BIT1C} x

Number: 71
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT1A ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT1A = CARD 𝕌(:α))
 [] |- (CARD IS_BIT1C = 1) ∧ FINITE IS_BIT1C
 [] |- FINITE IS_BIT1B ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT1B = CARD 𝕌(:α))
 [] |- ∀n. 2 * n = n + n
Goal: 
[FINITE 𝕌(:α), ¬((FINITE IS_BIT1A ∧ FINITE IS_BIT1B) ∧ FINITE IS_BIT1C)]
|- 1 = 2 * CARD 𝕌(:α) + 1

Number: 72
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT1A ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT1A = CARD 𝕌(:α))
 [] |- (CARD IS_BIT1C = 1) ∧ FINITE IS_BIT1C
 [] |- FINITE IS_BIT1B ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT1B = CARD 𝕌(:α))
 [] |- ∀n. 2 * n = n + n
Goal:  [FINITE IS_BIT1A, FINITE IS_BIT1B, FINITE IS_BIT1C, INFINITE 𝕌(:α)]
|- CARD (IS_BIT1A ∪ IS_BIT1B ∪ IS_BIT1C) = 1

Number: 73
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- FINITE IS_BIT1A ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT1A = CARD 𝕌(:α))
 [] |- (CARD IS_BIT1C = 1) ∧ FINITE IS_BIT1C
 [] |- FINITE IS_BIT1B ⇔ FINITE 𝕌(:α)
 [] |- FINITE 𝕌(:α) ⇒ (CARD IS_BIT1B = CARD 𝕌(:α))
 [] |- ∀n. 2 * n = n + n
Goal:  [FINITE 𝕌(:α), FINITE IS_BIT1A, FINITE IS_BIT1B, FINITE IS_BIT1C]
|- CARD IS_BIT1A + CARD IS_BIT1B = 2 * CARD 𝕌(:α)

Number: 74
Status: Parsing failed
Info: polymorph higher-order proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
 [] |- ∀x. x ∈ 𝕌(:α)
 [] |- ∀P x. x ∈ P ⇔ P x
Goal:  [] |- 𝕌 ARB () ⇔ {()} ()

Number: 75
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- dimindex (:α) = if FINITE 𝕌(:α) then CARD 𝕌(:α) else 1
 [] |- (CARD 𝕌(:unit) = 1) ∧ FINITE 𝕌(:unit)
Goal:  [] |- dimindex (:unit) = 1

Number: 76
Status: Time Out
Info: polymorph num proof 
Thm list: 
 [] |- dimword (:α) = 2 ** dimindex (:α)
 [] |- 0 < dimindex (:α)
 [] |- (∀m. m ** 0 = 1) ∧ ∀m n. m ** SUC n = m * m ** n
 [] |- ∀b. 1 < b ⇒ ∀n m. b ** m < b ** n ⇔ m < n
 [] |- 1 < 2
Goal:  [] |- 1 < dimword (:α)

Number: 77
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- (∀m. m ** 0 = 1) ∧ ∀m n. m ** SUC n = m * m ** n
 [] |- ∀a b c. a ≤ b ∧ c < b ⇒ a + c < 2 * b
Goal:  [∀f. SUM n (λi. SBIT (f i) i) < 2 ** n, SBIT (f n) n ≤ 2 ** n]
|- SBIT (f n) n + SUM n (λi. SBIT (f i) i) < 2 ** SUC n

Number: 78
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n f. SUM n (λi. SBIT (f i) i) < 2 ** n
Goal:  [n ≤ i, BIT i (SUM n (λj. SBIT (f j) j)) ⇔ f i ∧ i < n]
|- SUM n (λi. SBIT (f i) i) < 2 ** n

Number: 82
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- ∀n. 0 < n ⇒ ∀k. (k = k DIV n * n + k MOD n) ∧ k MOD n < n
Goal:  [Abbrev (WL = dimword (:α)), 0 < WL, WL = 2 * INT_MIN (:α)]
|- (n = n DIV WL * WL + n MOD WL) ∧ n MOD WL < WL

Number: 83
Status: Time Out
Info: bool num proof 
Thm list: 
 [] |- ∀n r. r < n ⇒ ∀q. (q * n + r) DIV n = q
 [] |- ∀m n. m * n = n * m
 [] |- ∀m n p. m * (n * p) = m * n * p
Goal: 
[Abbrev (q = (q * (2 * INT_MIN (:α)) + r) DIV (2 * INT_MIN (:α))),
 Abbrev (r = (q * (2 * INT_MIN (:α)) + r) MOD (2 * INT_MIN (:α))),
 Abbrev (2 * INT_MIN (:α) = dimword (:α)), ¬(INT_MIN (:α) ≤ r),
 r < INT_MIN (:α), r < 2 * INT_MIN (:α), 0 < 2 * INT_MIN (:α),
 ((q * (2 * INT_MIN (:α)) + r) DIV 2 ** (dimindex (:α) − 1)) MOD 2 = 1]
|- (q * (2 * INT_MIN (:α)) + r) DIV INT_MIN (:α) = 2 * q

Number: 84
Status: Time Out
Info: polymorph bool num proof 
Thm list: 
 [] |- 0 ≠ 1 ∧ 0 < 2
 [] |- ∀n. 0 < n ⇒ ∀k. (k * n) MOD n = 0
 [] |- ∀m n. m * n = n * m
 [] |- INT_MIN (:α) = 2 ** (dimindex (:α) − 1)
Goal: 
[Abbrev (WL = dimword (:α)), Abbrev (q = n DIV WL),
 Abbrev (r = n MOD WL), ¬(INT_MIN (:α) ≤ r), r < WL, r < INT_MIN (:α),
 0 < WL, WL = 2 * INT_MIN (:α), n = q * WL + r,
 n DIV INT_MIN (:α) = 2 * q,
 ((q * (2 * INT_MIN (:α)) + r) DIV 2 ** (dimindex (:α) − 1)) MOD 2 = 1]
|- F

Number: 85
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀a b n.
     ¬BIT n a ∨ ¬BIT n b ⇒
     (SBIT (BIT n a ∨ BIT n b) n = SBIT (BIT n a) n + SBIT (BIT n b) n)
 [] |- n < SUC n
Goal: 
[∀a b.
   (∀i. i < n ⇒ ¬BIT i a ∨ ¬BIT i b) ⇒
   (SUM n (λi. SBIT (BIT i a) i) + SUM n (λi. SBIT (BIT i b) i) =
    BITWISE n $\/ a b), ∀i. i < SUC n ⇒ ¬BIT i a ∨ ¬BIT i b]
|- SBIT (BIT n a) n + SBIT (BIT n b) n + BITWISE n $\/ a b =
   SBIT (BIT n a ∨ BIT n b) n + BITWISE n $\/ a b

Number: 86
Status: 
Info: polymorph proof 
Thm list: 
 []
|- ∀w.
     ¬(dimindex (:β) < dimindex (:α) ∧ dimindex (:β) < dimindex (:γ)) ⇒
     (sw2sw (sw2sw w) = sw2sw w)
Goal:  [¬(dimindex (:β) < dimindex (:α) ∧ dimindex (:β) < dimindex (:γ))]
|- sw2sw (sw2sw w) = sw2sw w

Number: 87
Status: Parsing failed
Info: num proof 
Thm list: 
 [] |- ∀m n. n < m ⇒ ∃p. m = n + (p + 1)
 [] |- ∀m. SUC m = m + 1
 [] |- (∀n. 0 + n = n) ∧ ∀m n. SUC m + n = SUC (m + n)
Goal: 
[T, i < dimindex (:α), 0 < dimindex (:α) − l, l ≤ dimindex (:α) − 1,
 dimindex (:α) ≤ SUC h] |- ∃x. dimindex (:α) − l = SUC x

Number: 99
Status: Unknown
Info: num proof 
Thm list: 
 [] |- ∀b n. n ≠ 0 ∧ n < 2 ** b ⇒ ∃i. i < b ∧ BIT i n
Goal:  [n ≠ 0, n < 2 ** dimindex (:α)] |- ∃i. i < dimindex (:α) ∧ BIT i n

Number: 135
Status: Time Out
Info: polymorph proof 
Thm list: 
 [] |- ∀w. -w + w = 0w
 [] |- ∀w. w + -w = 0w
 [] |- (∀w. w + 0w = w) ∧ ∀w. 0w + w = w
 [] |- ∀v w x. v + (w + x) = v + w + x
 [] |- ∀v w. v + w = w + v
Goal:  [] |- -a + -1w + b + 1w = b + -a

Number: 142
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal:  [FINITE {n2w n | n < k}, n < k, x = n2w n, {n2w n' | F} = ∅]
|- ∃n'. (n2w n = n2w n') ∧ (n' < k ∨ (n' = k))

Number: 143
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal:  [FINITE {n2w n | n < k}, x = n2w k, {n2w n | F} = ∅]
|- ∃n. (n2w k = n2w n) ∧ (n < k ∨ (n = k))

Number: 144
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal:  [FINITE {n2w n | n < k}, n < k, x = n2w n, {n2w n' | F} = ∅]
|- (n2w n = n2w k) ∨ ∃n'. (n2w n = n2w n') ∧ n' < k

Number: 154
Status: Time Out
Info: num proof 
Thm list: 
 [] |- ∀m n. ¬(m < n) ⇔ n ≤ m
 [] |- ∀n p. 2 ** p ≤ n ∧ n < 2 ** SUC p ⇒ (LOG2 n = p)
 [] |- ∀n. n ≠ 0 ⇒ BIT (LOG2 n) n
Goal: 
[BITS n 0 x + BITS n 0 y + 1 ≠ 0, BITS n 0 x + BITS n 0 y ≠ 0,
 ¬BIT (SUC n) x, ¬BIT (SUC n) (BITS n 0 x + BITS n 0 y + 1),
 BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC (SUC n),
 BITS n 0 x < 2 ** SUC n, BITS n 0 y < 2 ** SUC n, BIT (SUC n) y]
|- BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC n

Number: 155
Status: Time Out
Info: num proof 
Thm list: 
 [] |- ∀m n. ¬(m < n) ⇔ n ≤ m
 [] |- ∀n p. 2 ** p ≤ n ∧ n < 2 ** SUC p ⇒ (LOG2 n = p)
 [] |- ∀n. n ≠ 0 ⇒ BIT (LOG2 n) n
Goal: 
[BITS n 0 x + BITS n 0 y + 1 ≠ 0, BITS n 0 x + BITS n 0 y ≠ 0,
 ¬BIT (SUC n) y, ¬BIT (SUC n) (BITS n 0 x + BITS n 0 y + 1),
 BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC (SUC n),
 BITS n 0 x < 2 ** SUC n, BITS n 0 y < 2 ** SUC n, BIT (SUC n) x]
|- BITS n 0 x + BITS n 0 y + 1 < 2 ** SUC n

Number: 156
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀n a b.
     BIT (SUC n) (a + b) ⇔
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
       BIT (SUC n) a ⇔ BIT (SUC n) b
     else BIT (SUC n) a ⇎ BIT (SUC n) b
 []
|- ∀n a b.
     BIT (SUC n) (a + b + 1) ⇔
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b + 1) then
       BIT (SUC n) a ⇔ BIT (SUC n) b
     else BIT (SUC n) a ⇎ BIT (SUC n) b
Goal: 
[∀x y c.
   BSUM i (λi. BIT i x) (λi. BIT i y) c ⇔
   BIT i (x + y + if c then 1 else 0)]
|- ((BIT (SUC i) x ⇔ ¬BIT (SUC i) y) ⇔
    ¬BIT (SUC i) (BITS i 0 x + BITS i 0 y)) ⇔ BIT (SUC i) (x + y)

Number: 157
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀n a b.
     BIT (SUC n) (a + b) ⇔
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b) then
       BIT (SUC n) a ⇔ BIT (SUC n) b
     else BIT (SUC n) a ⇎ BIT (SUC n) b
 []
|- ∀n a b.
     BIT (SUC n) (a + b + 1) ⇔
     if BIT (SUC n) (BITS n 0 a + BITS n 0 b + 1) then
       BIT (SUC n) a ⇔ BIT (SUC n) b
     else BIT (SUC n) a ⇎ BIT (SUC n) b
Goal: 
[∀x y c.
   BSUM i (λi. BIT i x) (λi. BIT i y) c ⇔
   BIT i (x + y + if c then 1 else 0)]
|- ((BIT (SUC i) x ⇔ ¬BIT (SUC i) y) ⇔
    ¬BIT (SUC i) (BITS i 0 x + BITS i 0 y + 1)) ⇔
   BIT (SUC i) (x + y + 1)

Number: 158
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[∀P f.
   (∀j. j < n ⇒ ¬P j) ⇒
   (FOLDL (λa j. a ∨ P j ∧ f j) F (COUNT_LIST n) ⇔ F), ∀j. j < n ⇒ ¬P j,
 ∀j. j < SUC n ⇒ ¬P j] |- ¬FOLDL (λa j. a ∨ P j ∧ f j) F (COUNT_LIST n)

Number: 159
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[P i,
 ∀f P i.
   i < n ∧ P i ∧ (∀i j. P i ∧ P j ∧ i < n ∧ j < n ⇒ (i = j)) ⇒
   (FOLDL (λa j. a ∨ P j ∧ f j) F (COUNT_LIST n) ⇔ f i),
 ∀i j. P i ∧ P j ∧ i < n ∧ j < n ⇒ (i = j),
 ∀i j. P i ∧ P j ∧ i < SUC n ∧ j < SUC n ⇒ (i = j), i < n, i < SUC n]
|- FOLDL (λa j. a ∨ P j ∧ f j) F (COUNT_LIST n) ⇔ f i

Number: 160
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[P i,
 ∀f P i.
   i < n ∧ P i ∧ (∀i j. P i ∧ P j ∧ i < n ∧ j < n ⇒ (i = j)) ⇒
   (FOLDL (λa j. a ∨ P j ∧ f j) F (COUNT_LIST n) ⇔ f i),
 ∀i j. P i ∧ P j ∧ i < n ∧ j < n ⇒ (i = j), i < n, i < SUC n,
 FOLDL (λa j. a ∨ P j ∧ f j) F (COUNT_LIST n) ⇔ f i, P n ⇒ (n = i)]
|- f i ∨ P n ∧ f n ⇔ f i

Number: 164
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m. m ≤ m
 []
|- ∀P n m.
     1 < n ∧ n ≤ dimindex (:α) ⇒
     (FOLDL (λa j. a ∨ (m = n2w j) ∧ P j) F (COUNT_LIST n) ⇔
      FOLDL (λa j. a ∨ ((LOG2 (n − 1) -- 0) m = n2w j) ∧ P j) F
        (COUNT_LIST n) ∧
      ((dimindex (:α) − 1 -- LOG2 (n − 1) + 1) m = 0w))
Goal:  [dimindex (:α) ≠ 1, i < dimindex (:α), 1 < dimindex (:α)]
|- FOLDL (λa j. a ∨ (m = n2w j) ∧ j ≤ i ∧ w ' (i − j)) F
     (COUNT_LIST (dimindex (:α))) ⇔
   FOLDL
     (λa j.
        a ∨
        ((LOG2 (dimindex (:α) − 1) -- 0) m = n2w j) ∧ j ≤ i ∧
        w ' (i − j)) F (COUNT_LIST (dimindex (:α))) ∧
   ((dimindex (:α) − 1 -- LOG2 (dimindex (:α) − 1) + 1) m = 0w)

Number: 165
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m. m ≤ m
 []
|- ∀P n m.
     1 < n ∧ n ≤ dimindex (:α) ⇒
     (FOLDL (λa j. a ∨ (m = n2w j) ∧ P j) F (COUNT_LIST n) ⇔
      FOLDL (λa j. a ∨ ((LOG2 (n − 1) -- 0) m = n2w j) ∧ P j) F
        (COUNT_LIST n) ∧
      ((dimindex (:α) − 1 -- LOG2 (n − 1) + 1) m = 0w))
Goal:  [dimindex (:α) ≠ 1, i < dimindex (:α), 1 < dimindex (:α)]
|- FOLDL (λa j. a ∨ (m = n2w j) ∧ i + j < dimindex (:α) ∧ w ' (i + j)) F
     (COUNT_LIST (dimindex (:α))) ⇔
   FOLDL
     (λa j.
        a ∨
        ((LOG2 (dimindex (:α) − 1) -- 0) m = n2w j) ∧
        i + j < dimindex (:α) ∧ w ' (i + j)) F
     (COUNT_LIST (dimindex (:α))) ∧
   ((dimindex (:α) − 1 -- LOG2 (dimindex (:α) − 1) + 1) m = 0w)

Number: 166
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m. m ≤ m
 []
|- ∀P n m.
     1 < n ∧ n ≤ dimindex (:α) ⇒
     (FOLDL (λa j. a ∨ (m = n2w j) ∧ P j) F (COUNT_LIST n) ⇔
      FOLDL (λa j. a ∨ ((LOG2 (n − 1) -- 0) m = n2w j) ∧ P j) F
        (COUNT_LIST n) ∧
      ((dimindex (:α) − 1 -- LOG2 (n − 1) + 1) m = 0w))
Goal:  [dimindex (:α) ≠ 1, i < dimindex (:α), 1 < dimindex (:α)]
|- FOLDL (λa j. a ∨ (m = n2w j) ∧ (w ≫ j) ' i) F
     (COUNT_LIST (dimindex (:α))) ∨
   n2w (dimindex (:α) − 1) <₊ m ∧ word_msb w ⇔
   FOLDL
     (λa j.
        a ∨ ((LOG2 (dimindex (:α) − 1) -- 0) m = n2w j) ∧ (w ≫ j) ' i) F
     (COUNT_LIST (dimindex (:α))) ∧
   ((dimindex (:α) − 1 -- LOG2 (dimindex (:α) − 1) + 1) m = 0w) ∨
   n2w (dimindex (:α) − 1) <₊ m ∧ word_msb w

Number: 168
Status: Time Out
Info: num proof 
Thm list: 
 [] |- k ≠ 0 ⇒ (j % k % k = j % k)
 [] |- k ≠ 0 ⇒ ((i % k − j % k) % k = (i − j) % k)
Goal: 
[&(2 * INT_MIN (:α)) ≠ 0, n ≠ 0, 0 < dimword (:α),
 n MOD (2 * INT_MIN (:α)) < 2 * INT_MIN (:α), 1 ≤ INT_MIN (:α),
 1 ≤ dimword (:α), i = -&n, dimword (:α) = 2 * INT_MIN (:α), i < 0]
|- (&(2 * INT_MIN (:α)) − &n) % &(2 * INT_MIN (:α)) =
   (&(2 * INT_MIN (:α)) − &n % &(2 * INT_MIN (:α))) %
   &(2 * INT_MIN (:α))

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- ∀i.
     INT_MIN (:α) ≤ i ∧ i < 0 ∧ dimindex (:α) ≤ dimindex (:β) ⇒
     ∃n.
       INT_MIN (:α) ≤ n ∧ n < dimword (:α) ∧ (-n2w (Num (-i)) = n2w n) ∧
       (-n2w (Num (-i)) =
        n2w (2 ** dimindex (:β) − 2 ** dimindex (:α) + n))
Number: 174
Status: undefined
Info: polymorph 
Thm list: 
 []
|- ∀i.
     INT_MIN (:α) ≤ i ∧ i < 0 ∧ dimindex (:α) ≤ dimindex (:β) ⇒
     ∃n.
       INT_MIN (:α) ≤ n ∧ n < dimword (:α) ∧ (-n2w (Num (-i)) = n2w n) ∧
       (-n2w (Num (-i)) =
        n2w (2 ** dimindex (:β) − 2 ** dimindex (:α) + n))
Goal: 
[i < dimindex (:α), dimindex (:β) ≤ dimindex (:α), j ≤ INT_MAX (:β),
 INT_MIN (:β) ≤ j, j < 0]
|- ∃n.
     INT_MIN (:β) ≤ n ∧ n < dimword (:β) ∧ (-n2w (Num (-j)) = n2w n) ∧
     (-n2w (Num (-j)) =
      n2w (2 ** dimindex (:α) − 2 ** dimindex (:β) + n))

Number: 193
Status: Parsing failed
Info: num proof 
Thm list: 
Goal: 
[n ≠ 0, n ≠ UINT_MAX (:α),
 UINT_MAX (:α) ≤ n ∧ n ≠ UINT_MAX (:α) ⇔ dimword (:α) ≤ n]
|- (if UINT_MAX (:α) ≤ n then n2w (UINT_MAX (:α)) else n2w n) =
   if dimword (:α) ≤ n then n2w (UINT_MAX (:α)) else n2w n

Number: 206
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f. ∃g. ∀x. g x = case f x of NONE => [||] | SOME (a,b) => b:::g a
Goal:  []
|- ∃LUNFOLD.
     ∀f x.
       LUNFOLD f x =
       case f x of NONE => [||] | SOME (v1,v2) => v2:::LUNFOLD f v1

Number: 207
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀l1 l2. (if R l1 l2 then l1 else [||]) = if R l1 l2 then l2 else [||],
 ∀ll3 ll4.
   R ll3 ll4 ⇒
   (ll3 = [||]) ∧ (ll4 = [||]) ∨
   ∃h t1 t2. (ll3 = h:::t1) ∧ (ll4 = h:::t2) ∧ R t1 t2, R ll1 ll2,
 (∀x.
    (λ(l1,l2). if R l1 l2 then l1 else [||]) x =
    case
      (λ(l1,l2).
         if R l1 l2 then
           case LHD l1 of
             NONE => NONE
           | SOME h => SOME ((THE (LTL l1),THE (LTL l2)),h)
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::(λ(l1,l2). if R l1 l2 then l1 else [||]) a) ∧
 (∀x.
    (λ(l1,l2). if R l1 l2 then l2 else [||]) x =
    case
      (λ(l1,l2).
         if R l1 l2 then
           case LHD l1 of
             NONE => NONE
           | SOME h => SOME ((THE (LTL l1),THE (LTL l2)),h)
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::(λ(l1,l2). if R l1 l2 then l2 else [||]) a) ⇒
 ((λ(l1,l2). if R l1 l2 then l1 else [||]) =
  (λ(l1,l2). if R l1 l2 then l2 else [||]))] |- ll1 = ll2

Number: 214
Status: Unknown
Info: polymorph num proof 
Thm list: 
 []
|- llength_rel [||] 0 ∧
   ∀h n t. llength_rel t n ⇒ llength_rel (h:::t) (SUC n)
Goal:  [llength_rel t n] |- ∃n. llength_rel (h:::t) n

Number: 217
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- ∀t. LFINITE t ⇒ ∃n. llength_rel t n
Goal:  [LFINITE t] |- ∃n. llength_rel t n

Number: 224
Status: Unknown
Info: higher-order num proof 
Thm list: 
Goal:  []
|- (∀ll. exists P ll ⇒ ∃n a t. (LDROP n ll = SOME (a:::t)) ∧ P a) ⇒
   exists P ll ⇒
   ∃n a t. (LDROP n ll = SOME (a:::t)) ∧ P a

Number: 228
Status: Unknown
Info: num proof 
Thm list: 
 [] |- ∀m. (m = 0) ∨ ∃n. m = SUC n
Goal: 
[P n, P p, P (SUC n'), ∀m. m < n' ⇒ ¬P (SUC m), ∀m. m < p ⇒ ¬P m, ¬P 0,
 ¬(SUC n' < p), p < SUC n'] |- ∃p0. p = SUC p0

Number: 230
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀l. (l = [||]) ∨ ∃h t. l = h:::t
 [] |- (exists P [||] ⇔ F) ∧ (exists P (h:::t) ⇔ P h ∨ exists P t)
Goal: 
[∀x.
   (case
      (λll.
         if exists P ll then
           (let n = LEAST n. ∃e. (SOME e = LNTH n ll) ∧ P e
            in
              SOME (THE (LDROP (SUC n) ll),THE (LNTH n ll)))
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, Abbrev (n = LEAST n. ∃e. (SOME e = LNTH n ll) ∧ P e),
 ¬P (THE (LHD ll)), exists P ll] |- ∃h t. ll = h:::t

Number: 231
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀l. (l = [||]) ∨ ∃h t. l = h:::t
 [] |- (exists P [||] ⇔ F) ∧ (exists P (h:::t) ⇔ P h ∨ exists P t)
Goal: 
[P (THE (LHD ll)),
 ∀x.
   (case
      (λll.
         if exists P ll then
           (let n = LEAST n. ∃e. (SOME e = LNTH n ll) ∧ P e
            in
              SOME (THE (LDROP (SUC n) ll),THE (LNTH n ll)))
         else NONE) x
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, Abbrev (n = LEAST n. ∃e. (SOME e = LNTH n ll) ∧ P e),
 exists P ll] |- ∃h t. ll = h:::t

Number: 232
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀l. exists P l ⇔ ∃n e. (SOME e = LNTH n l) ∧ P e
Goal: 
[∀x.
   (case
      if exists P x then
        (let n = LEAST n. ∃e. (SOME e = LNTH n x) ∧ P e
         in
           SOME (THE (LDROP (SUC n) x),THE (LNTH n x)))
      else NONE
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, ¬P h, exists P t] |- ∃m e. (SOME e = LNTH m t) ∧ P e

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (∀n. LNTH n [||] = NONE) ∧ (∀h t. LNTH 0 (h:::t) = SOME h) ∧
   ∀n h t. LNTH (SUC n) (h:::t) = LNTH n t
Number: 233
Status: undefined
Info: polymorph 
Thm list: 
 [] |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
 []
|- (∀n. LNTH n [||] = NONE) ∧ (∀h t. LNTH 0 (h:::t) = SOME h) ∧
   ∀n h t. LNTH (SUC n) (h:::t) = LNTH n t
Goal: 
[P e, P h,
 ∀x.
   (case
      if exists P x then
        (let n = LEAST n. ∃e. (SOME e = LNTH n x) ∧ P e
         in
           SOME (THE (LDROP (SUC n) x),THE (LNTH n x)))
      else NONE
    of
      NONE => [||]
    | SOME (a,b) => b:::g P a) =
   g P x, ∀m. m < n ⇒ ∀e. SOME e ≠ LNTH m (h:::t) ∨ ¬P e, n ≠ 0, 0 < n,
 SOME e = LNTH n (h:::t)] |- F

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 234
Status: undefined
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀l. (l = [||]) ∨ ∃h t. l = h:::t
 [] |- (every P [||] ⇔ T) ∧ (every P (h:::t) ⇔ P h ∧ every P t)
Goal: 
[∀x.
   LHD (g x) =
   OPTION_MAP SND
     ((λll.
         if every ($= [||]) ll then NONE
         else
           (let n = LEAST n. ∃e. (SOME e = LNTH n ll) ∧ e ≠ [||] in
            let nlist = THE (LNTH n ll)
            in
              SOME
                (THE (LTL nlist):::THE (LDROP (SUC n) ll),
                 THE (LHD nlist)))) x),
 ∀x.
   LTL (g x) =
   OPTION_MAP (g o FST)
     ((λll.
         if every ($= [||]) ll then NONE
         else
           (let n = LEAST n. ∃e. (SOME e = LNTH n ll) ∧ e ≠ [||] in
            let nlist = THE (LNTH n ll)
            in
              SOME
                (THE (LTL nlist):::THE (LDROP (SUC n) ll),
                 THE (LHD nlist)))) x), ¬every ($= [||]) ll]
|- ∃h t. ll = h:::t

Number: 235
Status: 
Info: num proof 
Thm list: 
Goal:  [[||] ≠ e, h = [||], SOME e = LNTH n t]
|- ∃n e. (SOME e = LNTH n t) ∧ e ≠ [||]

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 236
Status: undefined
Info: higher-order num proof 
Thm list: 
Goal:  [e ≠ [||], ¬every ($= [||]) t, SOME e = LNTH n t]
|- ∃e'. (SOME e' = LNTH n t) ∧ e' ≠ [||]

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 237
Status: undefined
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀ll.
     ((LHD ll = NONE) ⇔ (ll = [||])) ∧ ((NONE = LHD ll) ⇔ (ll = [||]))
 [] |- ∀l. (l = [||]) ∨ ∃h t. l = h:::t
 [] |- ∀x. SOME x ≠ NONE
Goal: 
[e ≠ [||], ¬every ($= [||]) t,
 LHD (g t) =
 SOME
   (THE
      (LHD
         (THE (LNTH (LEAST n. ∃e. (SOME e = LNTH n t) ∧ e ≠ [||]) t)))),
 LHD (g ([||]:::t)) =
 SOME
   (THE
      (LHD
         (THE (LNTH (LEAST n. ∃e. (SOME e = LNTH n t) ∧ e ≠ [||]) t)))),
 LTL (g t) =
 SOME
   (g
      (THE
         (LTL
            (THE
               (LNTH (LEAST n. ∃e. (SOME e = LNTH n t) ∧ e ≠ [||])
                  t))):::
           THE
             (LDROP (SUC (LEAST n. ∃e. (SOME e = LNTH n t) ∧ e ≠ [||]))
                t))),
 LTL (g ([||]:::t)) =
 SOME
   (g
      (THE
         (LTL
            (THE
               (LNTH (LEAST n. ∃e. (SOME e = LNTH n t) ∧ e ≠ [||])
                  t))):::
           THE
             (LDROP (SUC (LEAST n. ∃e. (SOME e = LNTH n t) ∧ e ≠ [||]))
                t))), SOME e = LNTH n t] |- ∃h1 t1. g t = h1:::t1

Number: 238
Status: Parsing failed
Info: proof 
Thm list: 
Goal: 
[∀x.
   (f x = [||]) ∧ (g x = [||]) ∨
   ∃h y. (f x = h:::f y) ∧ (g x = h:::g y)]
|- (f x = [||]) ∧ (g x = [||]) ∨
   ∃h t1 t2.
     (f x = h:::t1) ∧ (g x = h:::t2) ∧ ∃x. (t1 = f x) ∧ (t2 = g x)

Number: 239
Status: 
Info: proof 
Thm list: 
Goal: 
[∀x.
   (f x = [||]) ∧ (g x = [||]) ∨
   ∃h y. (f x = h:::f y) ∧ (g x = h:::g y)]
|- ∃x'. (f x = f x') ∧ (g x = g x')

Number: 245
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀r s s'.
     linear_order r s ∧ finite_prefixes r s ∧ x ∈ s' ∧ s' ⊆ s ⇒
     SING (minimal_elements s' r)
 [] |- ∀s. s ⊆ s
Goal: 
[∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo X x.
     x ∈ X ∧ (s' = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x,
 FINITE {y | (y,x) ∈ lo}, x ∈ X, finite_prefixes lo X,
 linear_order lo X] |- SING (minimal_elements X lo)

Number: 246
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀x y z. (x,y) ∈ lo ∧ (y,z) ∈ lo ⇒ (x,z) ∈ lo,
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x y. (x,y) ∈ lo ∧ (y,x) ∈ lo ⇒ (x = y),
 ∀x. x ∈ X ∧ (∀x''. x'' ∈ X ∧ (x'',x) ∈ lo ⇒ (x = x'')) ⇔ (x = x'),
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo' X' x''.
     x'' ∈ X' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     (domain lo' ⊆ X' ∧ range lo' ⊆ X' ∧
      (∀x y z. (x,y) ∈ lo' ∧ (y,z) ∈ lo' ⇒ (x,z) ∈ lo') ∧
      (∀x y. (x,y) ∈ lo' ∧ (y,x) ∈ lo' ⇒ (x = y)) ∧
      ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'',
 FINITE {y | (y,x) ∈ lo}, x ∈ X, domain lo ⊆ X, range lo ⊆ X,
 finite_prefixes lo X]
|- ∃x''. (x'',x) ∈ lo ∧ (x'' ∈ X ∧ x'' ≠ x') ∧ x ≠ x' ⇎ (x'',x) ∈ lo

Number: 249
Status: Unknown
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo X x.
     x ∈ X ∧ (s' = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x,
 FINITE {y | (y,x) ∈ lo}, ¬(x ∉ X DIFF minimal_elements X lo),
 minimal_elements X lo = {x'}, x ∈ X,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, X DIFF minimal_elements X lo ⊆ X,
 finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo), linear_order lo X,
 linear_order (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∃i.
     LNTH i
       (LUNFOLD linear_order_to_list_f
          (rrestrict lo (X DIFF minimal_elements X lo))) =
     SOME x

Number: 250
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[T,
 ∀x' y.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y ∈ X ∧
   y ∉ minimal_elements X lo ⇒
   (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y,x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo' X' x''.
     x'' ∈ X' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'',
 FINITE {y | (y,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)),
 x ∉ minimal_elements X lo,
 LNTH i
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME x, x ∈ X, x'' ∈ minimal_elements (domain lo ∪ range lo) lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x'''. (∃y. (x''',y) ∈ lo) ∨ (∃x. (x,x''') ∈ lo) ⇔ x''' ∈ X

Number: 251
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[T,
 ∀x' y.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y ∈ X ∧
   y ∉ minimal_elements X lo ⇒
   (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y,x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x. x ∉ minimal_elements (domain lo ∪ range lo) lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo' X' x''.
     x'' ∈ X' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'',
 FINITE {y | (y,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)),
 x ∉ minimal_elements X lo,
 LNTH i
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME x, x ∈ X,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 253
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[T,
 ∀x' y.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y ∈ X ∧
   y ∉ minimal_elements X lo ⇒
   (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y,x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo' X' x''.
     x'' ∈ X' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'',
 FINITE {y | (y,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)), x ∈ X,
 x ∈ minimal_elements X lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 254
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[T,
 ∀x' y.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y ∈ X ∧
   y ∉ minimal_elements X lo ⇒
   (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y,x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo' X' x''.
     x'' ∈ X' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'',
 FINITE {y | (y,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)), x ∉ X, x ∈ X,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 255
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo X x.
     x ∈ X ∧ (s' = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x,
 FINITE {y | (y,x) ∈ lo},
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ range lo,
 x ∈ minimal_elements (domain lo ∪ range lo) lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 256
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo X x.
     x ∈ X ∧ (s' = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x,
 FINITE {y | (y,x) ∈ lo}, x ∉ domain lo, x ∉ range lo,
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ range lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 257
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo X x.
     x ∈ X ∧ (s' = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x,
 FINITE {y | (y,x) ∈ lo},
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ domain lo,
 x ∈ minimal_elements (domain lo ∪ range lo) lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 258
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {y | (y,x) ∈ lo} ⇒
   ∀lo X x.
     x ∈ X ∧ (s' = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x,
 FINITE {y | (y,x) ∈ lo}, x ∉ domain lo, x ∉ range lo,
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ domain lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 262
Status: Time Out
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x. (∃x'. (x',x) ∈ lo) ⇒ x ∈ X, ∀x. (∃y. (x,y) ∈ lo) ⇒ x ∈ X,
 ∀x'.
   ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧
   (x',
    CHOICE
      {x |
       ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
       ∀x'.
         ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒
         (x = x')}) ∈ lo ⇒
   (CHOICE
      {x |
       ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
       ∀x'.
         ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒
         (x = x')} =
    x'), antisym lo, transitive lo,
 {x |
  ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
  ∀x'. ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒ (x = x')} ≠
 ∅,
 (x',
  CHOICE
    {x |
     ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
     ∀x'.
       ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒
       (x = x')}) ∈ lo]
|- CHOICE
     {x |
      ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
      ∀x''.
        ((∃y. (x'',y) ∈ lo) ∨ ∃x. (x,x'') ∈ lo) ∧ (x'',x) ∈ lo ⇒
        (x = x'')} ∈ X

Number: 263
Status: Time Out
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x. (∃x'. (x',x) ∈ lo) ⇒ x ∈ X, ∀x. (∃y. (x,y) ∈ lo) ⇒ x ∈ X,
 ∀x'.
   ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧
   (x',
    CHOICE
      {x |
       ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
       ∀x'.
         ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒
         (x = x')}) ∈ lo ⇒
   (CHOICE
      {x |
       ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
       ∀x'.
         ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒
         (x = x')} =
    x'), antisym lo, transitive lo,
 {x |
  ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
  ∀x'. ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒ (x = x')} ≠
 ∅,
 (CHOICE
    {x |
     ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
     ∀x'.
       ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒ (x = x')},
  y) ∈ lo]
|- CHOICE
     {x |
      ((∃y. (x,y) ∈ lo) ∨ ∃x'. (x',x) ∈ lo) ∧
      ∀x'.
        ((∃y. (x',y) ∈ lo) ∨ ∃x. (x,x') ∈ lo) ∧ (x',x) ∈ lo ⇒
        (x = x')} ∈ X

Number: 264
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x. (∃x'. (x',x) ∈ lo) ⇒ x ∈ X, ∀x. (∃y. (x,y) ∈ lo) ⇒ x ∈ X,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x' y'.
     (x',y') ∈ lo' ∧ (s' = {z | (z,x') ∈ lo'}) ∧
     ((∀x'. (∃y. (x',y) ∈ lo') ⇒ x' ∈ X') ∧
      (∀x'. (∃x. (x,x') ∈ lo') ⇒ x' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 FINITE {z | (z,x) ∈ lo}, antisym lo, transitive lo, (x,y) ∈ lo,
 finite_prefixes lo X] |- x ∈ X ∧ y ∈ X

Number: 265
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀r s s'.
     linear_order r s ∧ finite_prefixes r s ∧ x ∈ s' ∧ s' ⊆ s ⇒
     SING (minimal_elements s' r)
 [] |- ∀s. s ⊆ s
Goal: 
[∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, x ∈ X, y ∈ X, (x,y) ∈ lo,
 finite_prefixes lo X, linear_order lo X]
|- SING (minimal_elements X lo)

Number: 266
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀x y z. (x,y) ∈ lo ∧ (y,z) ∈ lo ⇒ (x,z) ∈ lo,
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x y. (x,y) ∈ lo ∧ (y,x) ∈ lo ⇒ (x = y),
 ∀x. x ∈ X ∧ (∀x''. x'' ∈ X ∧ (x'',x) ∈ lo ⇒ (x = x'')) ⇔ (x = x'),
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     (domain lo' ⊆ X' ∧ range lo' ⊆ X' ∧
      (∀x y z. (x,y) ∈ lo' ∧ (y,z) ∈ lo' ⇒ (x,z) ∈ lo') ∧
      (∀x y. (x,y) ∈ lo' ∧ (y,x) ∈ lo' ⇒ (x = y)) ∧
      ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 FINITE {z | (z,x) ∈ lo}, x ∈ X, y ∈ X, (x,y) ∈ lo, domain lo ⊆ X,
 range lo ⊆ X, finite_prefixes lo X]
|- ∃x''. (x'',x) ∈ lo ∧ (x'' ∈ X ∧ x'' ≠ x') ∧ x ≠ x' ⇎ (x'',x) ∈ lo

Number: 267
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀r s s'. linear_order r s ∧ s' ⊆ s ⇒ linear_order (rrestrict r s') s'
Goal: 
[∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, minimal_elements X lo = {x'}, x ∈ X, y ∈ X,
 (x,y) ∈ lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, X DIFF minimal_elements X lo ⊆ X,
 finite_prefixes lo X, linear_order lo X]
|- linear_order (rrestrict lo (X DIFF minimal_elements X lo))
     (X DIFF minimal_elements X lo)

Number: 268
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀r s s'.
     finite_prefixes r s ∧ s' ⊆ s ⇒
     finite_prefixes r s' ∧ finite_prefixes (rrestrict r s') s'
Goal: 
[∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, minimal_elements X lo = {x'}, x ∈ X, y ∈ X,
 (x,y) ∈ lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, X DIFF minimal_elements X lo ⊆ X,
 finite_prefixes lo X, linear_order lo X,
 linear_order (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
     (X DIFF minimal_elements X lo)

Number: 269
Status: Parsing failed
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[T,
 ∀x''.
   x'' ∈ X ∧ (∀x'. x' ∈ X ∧ (x',x'') ∈ lo ⇒ (x'' = x')) ⇔ (x'' = x'),
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     linear_order lo' X' ∧ finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 FINITE {z | (z,x) ∈ lo}, x ≠ x'', x ∈ X, x'' ∈ X, y ∈ X, (x,y) ∈ lo,
 (x'',x) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')})} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes
   (rrestrict lo
      (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')}))
   (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')}),
 linear_order lo X,
 linear_order
   (rrestrict lo
      (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')}))
   (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')})]
|- y ≠ x'

Number: 270
Status: Parsing failed
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[T,
 ∀x''.
   x'' ∈ X ∧ (∀x'. x' ∈ X ∧ (x',x'') ∈ lo ⇒ (x'' = x')) ⇔ (x'' = x'),
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     linear_order lo' X' ∧ finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 FINITE {z | (z,x) ∈ lo}, x ∉ X, x ∈ X, y ∈ X, (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')})} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes
   (rrestrict lo
      (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')}))
   (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')}),
 linear_order lo X,
 linear_order
   (rrestrict lo
      (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')}))
   (X DIFF {x | x ∈ X ∧ ∀x'. x' ∈ X ∧ (x',x) ∈ lo ⇒ (x = x')})]
|- y ≠ x'

Number: 271
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, ¬(x ∉ X DIFF minimal_elements X lo),
 y ∉ minimal_elements X lo, minimal_elements X lo = {x'}, x ∈ X, y ∈ X,
 (x,y) ∈ lo, (x,y) ∈ rrestrict lo (X DIFF minimal_elements X lo),
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, X DIFF minimal_elements X lo ⊆ X,
 finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo), linear_order lo X,
 linear_order (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∃i j.
     i ≤ j ∧
     (LNTH i
        (LUNFOLD linear_order_to_list_f
           (rrestrict lo (X DIFF minimal_elements X lo))) =
      SOME x) ∧
     (LNTH j
        (LUNFOLD linear_order_to_list_f
           (rrestrict lo (X DIFF minimal_elements X lo))) =
      SOME y)

Number: 272
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
Goal: 
[T,
 ∀x' y'.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y' ∈ X ∧
   y' ∉ minimal_elements X lo ⇒
   (x',y') ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y',x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 Abbrev (∀x. x ∈ min ⇔ x ∈ minimal_elements (domain lo ∪ range lo) lo),
 FINITE {z | (z,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)),
 x ∉ minimal_elements X lo, y ∉ minimal_elements X lo, i ≤ j,
 LNTH i
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME x,
 LNTH j
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME y, x ∈ X, x'' ∈ min, y ∈ X, (x,y) ∈ lo,
 (x,y) ∈ rrestrict lo (X DIFF minimal_elements X lo),
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x'''. (∃y. (x''',y) ∈ lo) ∨ (∃x. (x,x''') ∈ lo) ⇔ x''' ∈ X

Number: 273
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
Goal: 
[T,
 ∀x' y'.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y' ∈ X ∧
   y' ∉ minimal_elements X lo ⇒
   (x',y') ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y',x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 Abbrev (∀x. x ∉ minimal_elements (domain lo ∪ range lo) lo),
 FINITE {z | (z,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)),
 x ∉ minimal_elements X lo, y ∉ minimal_elements X lo, i ≤ j,
 LNTH i
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME x,
 LNTH j
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME y, x ∈ X, y ∈ X, (x,y) ∈ lo,
 (x,y) ∈ rrestrict lo (X DIFF minimal_elements X lo),
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 274
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
Goal: 
[T,
 ∀x' y'.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y' ∈ X ∧
   y' ∉ minimal_elements X lo ⇒
   (x',y') ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y',x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 Abbrev (∀x. x ∈ min ⇔ x ∈ minimal_elements (domain lo ∪ range lo) lo),
 FINITE {z | (z,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)),
 x ∉ minimal_elements X lo, y ∉ minimal_elements X lo, i ≤ j,
 LNTH i
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME x,
 LNTH j
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME y, x ∈ X, x'' ∈ min, y ∈ X, (x,y) ∈ lo,
 (x,y) ∈ rrestrict lo (X DIFF minimal_elements X lo),
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x'''. (∃y. (x''',y) ∈ lo) ∨ (∃x. (x,x''') ∈ lo) ⇔ x''' ∈ X

Number: 275
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
Goal: 
[T,
 ∀x' y'.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y' ∈ X ∧
   y' ∉ minimal_elements X lo ⇒
   (x',y') ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y',x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 Abbrev (∀x. x ∉ minimal_elements (domain lo ∪ range lo) lo),
 FINITE {z | (z,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)),
 x ∉ minimal_elements X lo, y ∉ minimal_elements X lo, i ≤ j,
 LNTH i
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME x,
 LNTH j
   (LUNFOLD linear_order_to_list_f
      (rrestrict lo (X DIFF minimal_elements X lo))) =
 SOME y, x ∈ X, y ∈ X, (x,y) ∈ lo,
 (x,y) ∈ rrestrict lo (X DIFF minimal_elements X lo),
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 276
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀s.
     FINITE s ⇒
     ∀lo X x.
       x ∈ X ∧ (s = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
       finite_prefixes lo X ⇒
       ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x
 [] |- ∀r s. finite_prefixes r s ⇔ ∀e. e ∈ s ⇒ FINITE {e' | (e',e) ∈ r}
Goal: 
[∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, x ∉ X DIFF minimal_elements X lo,
 minimal_elements X lo = {x'}, x ∈ X, y ∈ X, (x,y) ∈ lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, X DIFF minimal_elements X lo ⊆ X,
 finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo), linear_order lo X,
 linear_order (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∃j. LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y

Number: 277
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[T,
 ∀x' y.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y ∈ X ∧
   y ∉ minimal_elements X lo ⇒
   (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y,x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 FINITE {z | (z,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)), x ∈ X,
 x ∈ minimal_elements X lo, y ∈ X, (x,y) ∈ lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 278
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[T,
 ∀x' y.
   (x' ∈ X ∧ x' ∉ minimal_elements X lo) ∧ y ∈ X ∧
   y ∉ minimal_elements X lo ⇒
   (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo) ∨
   (y,x') ∈ rrestrict lo (X DIFF minimal_elements X lo),
 ∀x y. x ∈ X ∧ y ∈ X ⇒ (x,y) ∈ lo ∨ (y,x) ∈ lo,
 ∀x''. x'' ∈ minimal_elements X lo ⇔ (x'' = x'),
 ∀x''. (∃x. (x,x'') ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃x. (x,x') ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀x''. (∃y. (x'',y) ∈ lo) ⇒ x'' ∈ X,
 ∀x'.
   (∃y. (x',y) ∈ rrestrict lo (X DIFF minimal_elements X lo)) ⇒
   x' ∈ X ∧ x' ∉ minimal_elements X lo,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo' X' x'' y'.
     (x'',y') ∈ lo' ∧ (∀x'''. x''' ∈ s' ⇔ (x''',x'') ∈ lo') ∧
     ((∀x''. (∃y. (x'',y) ∈ lo') ⇒ x'' ∈ X') ∧
      (∀x''. (∃x. (x,x'') ∈ lo') ⇒ x'' ∈ X') ∧ transitive lo' ∧
      antisym lo' ∧ ∀x y. x ∈ X' ∧ y ∈ X' ⇒ (x,y) ∈ lo' ∨ (y,x) ∈ lo') ∧
     finite_prefixes lo' X' ⇒
     ∃i j.
       i ≤ j ∧
       (LNTH i (LUNFOLD linear_order_to_list_f lo') = SOME x'') ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo') = SOME y'),
 FINITE {z | (z,x) ∈ lo}, antisym lo,
 antisym (rrestrict lo (X DIFF minimal_elements X lo)), transitive lo,
 transitive (rrestrict lo (X DIFF minimal_elements X lo)), x ∉ X, x ∈ X,
 y ∈ X, (x,y) ∈ lo,
 {y | (y,x) ∈ rrestrict lo (X DIFF minimal_elements X lo)} ⊂
 {y | (y,x) ∈ lo}, finite_prefixes lo X,
 finite_prefixes (rrestrict lo (X DIFF minimal_elements X lo))
   (X DIFF minimal_elements X lo)]
|- ∀x''. (∃y. (x'',y) ∈ lo) ∨ (∃x. (x,x'') ∈ lo) ⇔ x'' ∈ X

Number: 279
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo},
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ range lo,
 x ∈ minimal_elements (domain lo ∪ range lo) lo, y ∈ range lo,
 (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 280
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, x ∉ domain lo, x ∉ range lo,
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ range lo,
 y ∈ range lo, (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 281
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo},
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ range lo,
 x ∈ minimal_elements (domain lo ∪ range lo) lo, y ∈ domain lo,
 (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 282
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, x ∉ domain lo, x ∉ range lo,
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ range lo,
 y ∈ domain lo, (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 283
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo},
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ domain lo,
 x ∈ minimal_elements (domain lo ∪ range lo) lo, y ∈ range lo,
 (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 284
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, x ∉ domain lo, x ∉ range lo,
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ domain lo,
 y ∈ range lo, (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 285
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo},
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ domain lo,
 x ∈ minimal_elements (domain lo ∪ range lo) lo, y ∈ domain lo,
 (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 286
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x ∈ {y} ⇔ (x = y)
Goal: 
[T,
 ∀s'.
   s' ⊂ {z | (z,x) ∈ lo} ⇒
   ∀lo X x y.
     (x,y) ∈ lo ∧ (s' = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
     finite_prefixes lo X ⇒
     ∃i j.
       i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
       (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y),
 FINITE {z | (z,x) ∈ lo}, x ∉ domain lo, x ∉ range lo,
 minimal_elements (domain lo ∪ range lo) lo = {x'}, x ∈ domain lo,
 y ∈ domain lo, (x,y) ∈ lo,
 {y |
  (y,x) ∈
  rrestrict lo
    (domain lo ∪ range lo DIFF
     minimal_elements (domain lo ∪ range lo) lo)} ⊂ {y | (y,x) ∈ lo},
 finite_prefixes lo (domain lo ∪ range lo),
 finite_prefixes
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo),
 linear_order lo (domain lo ∪ range lo),
 linear_order
   (rrestrict lo
      (domain lo ∪ range lo DIFF
       minimal_elements (domain lo ∪ range lo) lo))
   (domain lo ∪ range lo DIFF
    minimal_elements (domain lo ∪ range lo) lo)] |- x' = x

Number: 294
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀s.
     FINITE s ⇒
     ∀lo X x.
       x ∈ X ∧ (s = {y | (y,x) ∈ lo}) ∧ linear_order lo X ∧
       finite_prefixes lo X ⇒
       ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x
 [] |- ∀r s. finite_prefixes r s ⇔ ∀e. e ∈ s ⇒ FINITE {e' | (e',e) ∈ r}
 []
|- ∀i lo X x.
     linear_order lo X ∧
     (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ⇒
     x ∈ X
Goal:  [finite_prefixes lo X, linear_order lo X]
|- x ∈ X ⇔ ∃i. LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x

Number: 298
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀s.
     FINITE s ⇒
     ∀lo X x y.
       (x,y) ∈ lo ∧ (s = {z | (z,x) ∈ lo}) ∧ linear_order lo X ∧
       finite_prefixes lo X ⇒
       ∃i j.
         i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME x) ∧
         (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME y)
 [] |- ∀r s. finite_prefixes r s ⇔ ∀e. e ∈ s ⇒ FINITE {e' | (e',e) ∈ r}
Goal:  [y ∈ X, (y,z) ∈ lo, finite_prefixes lo X, linear_order lo X]
|- ∃i j.
     i ≤ j ∧ (LNTH i (LUNFOLD linear_order_to_list_f lo) = SOME y) ∧
     (LNTH j (LUNFOLD linear_order_to_list_f lo) = SOME z)

Number: 311
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀t' u. (if R t' u then t' else Lf) = if R t' u then u else Lf,
 ∀t u.
   R t u ⇒
   (t = Lf) ∧ (u = Lf) ∨
   ∃a t1 u1 t2 u2.
     R t1 u1 ∧ R t2 u2 ∧ (t = Nd a t1 t2) ∧ (u = Nd a u1 u2), R t u,
 (∀x.
    (λ(t,u). if R t u then t else Lf) x =
    case
      (λ(t,u).
         if R t u then
           lbtree_case NONE
             (λa t1 t2.
                SOME
                  (a,(t1,@u1. ∃u2. u = Nd a u1 u2),t2,
                   @u2. ∃u1. u = Nd a u1 u2)) t
         else NONE) x
    of
      NONE => Lf
    | SOME (b,y,z) =>
        Nd b ((λ(t,u). if R t u then t else Lf) y)
          ((λ(t,u). if R t u then t else Lf) z)) ∧
 (∀x.
    (λ(t,u). if R t u then u else Lf) x =
    case
      (λ(t,u).
         if R t u then
           lbtree_case NONE
             (λa t1 t2.
                SOME
                  (a,(t1,@u1. ∃u2. u = Nd a u1 u2),t2,
                   @u2. ∃u1. u = Nd a u1 u2)) t
         else NONE) x
    of
      NONE => Lf
    | SOME (b,y,z) =>
        Nd b ((λ(t,u). if R t u then u else Lf) y)
          ((λ(t,u). if R t u then u else Lf) z)) ⇒
 ((λ(t,u). if R t u then t else Lf) =
  (λ(t,u). if R t u then u else Lf))] |- t = u

Number: 313
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- Lf ≠ Nd a t1 t2
 [] |- (Nd a1 t1 u1 = Nd a2 t2 u2) ⇔ (a1 = a2) ∧ (t1 = t2) ∧ (u1 = u2)
Goal: 
[∀t u.
   R t u ⇒
   (t = Lf) ∧ (u = Lf) ∨
   ∃a t1 u1 t2 u2.
     R t1 u1 ∧ R t2 u2 ∧ (t = Nd a t1 t2) ∧ (u = Nd a u1 u2), R p_1 p_2,
 R t u, p_2 = Nd a u1 u2]
|- ∃t1 t2. (p_1 = Nd a t1 t2) ∧ R t1 u1 ∧ R t2 u2

Number: 316
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- Lf ≠ Nd a t1 t2
 [] |- (Nd a1 t1 u1 = Nd a2 t2 u2) ⇔ (a1 = a2) ∧ (t1 = t2) ∧ (u1 = u2)
Goal: 
[∀t u.
   R t u ⇒
   (t = Lf) ∧ (u = Lf) ∨
   ∃a t1 u1 t2 u2.
     R t1 u1 ∧ R t2 u2 ∧ (t = Nd a t1 t2) ∧ (u = Nd a u1 u2), R p_1 p_2,
 R t u, p_1 = Nd a t1 t2]
|- ∃u1 u2. (p_2 = Nd a u1 u2) ∧ R t1 u1 ∧ R t2 u2

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 326
Status: undefined
Info: polymorph higher-order proof 
Thm list: 
 [] |- ∀t. (t = Lf) ∨ ∃a t1 t2. t = Nd a t1 t2
Goal:  [(bf_flatten l = [||]) ⇔ EVERY ($= Lf) l]
|- (h = Lf) ∨ ∃a t1 t2. h = Nd a t1 t2

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 330
Status: undefined
Info: polymorph higher-order proof 
Thm list: 
 [] |- ∀t. (t = Lf) ∨ ∃a t1 t2. t = Nd a t1 t2
Goal: 
[∀tlist. (l = bf_flatten tlist) ⇒ EXISTS (mem x) tlist, Lf ≠ y,
 ¬EVERY ($= Lf) tlist, tlist = l1 ++ y::l2, h:::l = bf_flatten tlist,
 EVERY ($= Lf) l1, EVERY ($~ o $~ o $= Lf) l1,
 EXISTS ($~ o $= Lf) tlist, ($~ o $= Lf) y] |- ∃a t1 t2. y = Nd a t1 t2

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 334
Status: undefined
Info: polymorph higher-order proof 
Thm list: 
 [] |- ∀t. (t = Lf) ∨ ∃a t1 t2. t = Nd a t1 t2
Goal: 
[Lf ≠ x, ¬EVERY ($= Lf) tlist, tlist = l1 ++ x::l2,
 h:::t = bf_flatten tlist, EVERY ($= Lf) l1, EVERY ($~ o $~ o $= Lf) l1,
 EXISTS ($~ o $= Lf) tlist, ($~ o $= Lf) x] |- ∃a t1 t2. x = Nd a t1 t2

Number: 335
Status: Unknown
Info: polymorph num proof 
Thm list: 
 []
|- (∀x t1 t2. depth x (Nd x t1 t2) 0) ∧
   (∀m x a t1 t2. depth x t1 m ⇒ depth x (Nd a t1 t2) (SUC m)) ∧
   ∀m x a t1 t2. depth x t2 m ⇒ depth x (Nd a t1 t2) (SUC m)
Goal:  [depth x t n] |- ∃n. depth x (Nd b t1 t) n

Number: 336
Status: Unknown
Info: polymorph num proof 
Thm list: 
 []
|- (∀x t1 t2. depth x (Nd x t1 t2) 0) ∧
   (∀m x a t1 t2. depth x t1 m ⇒ depth x (Nd a t1 t2) (SUC m)) ∧
   ∀m x a t1 t2. depth x t2 m ⇒ depth x (Nd a t1 t2) (SUC m)
Goal:  [depth x t n] |- ∃n. depth x (Nd b t t2) n

Number: 338
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- ∀x t. mem x t ⇒ ∃n. depth x t n
 []
|- (∀x t1 t2. depth x (Nd x t1 t2) 0) ∧
   (∀m x a t1 t2. depth x t1 m ⇒ depth x (Nd a t1 t2) (SUC m)) ∧
   ∀m x a t1 t2. depth x t2 m ⇒ depth x (Nd a t1 t2) (SUC m)
Goal:  [∀m. m < n ⇒ ¬depth x t2 m, x ≠ a, ¬mem x t1, mem x t2, depth x t2 n]
|- ∃n. depth x (Nd a t1 t2) n

Number: 340
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- SUC x < SUC y ⇔ x < y
 []
|- (∀x t1 t2. depth x (Nd x t1 t2) 0) ∧
   (∀m x a t1 t2. depth x t1 m ⇒ depth x (Nd a t1 t2) (SUC m)) ∧
   ∀m x a t1 t2. depth x t2 m ⇒ depth x (Nd a t1 t2) (SUC m)
Goal: 
[∀n. ¬depth x t1 n, ∀m. m < n ⇒ ¬depth x t2 m,
 ∀m'. m' < SUC m ⇒ ¬depth x (Nd a t1 t2) m', x ≠ a, ¬mem x t1, n < m,
 mem x t2, depth x t2 m, depth x t2 n] |- F

Number: 342
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- ∀x t. mem x t ⇒ ∃n. depth x t n
 []
|- (∀x t1 t2. depth x (Nd x t1 t2) 0) ∧
   (∀m x a t1 t2. depth x t1 m ⇒ depth x (Nd a t1 t2) (SUC m)) ∧
   ∀m x a t1 t2. depth x t2 m ⇒ depth x (Nd a t1 t2) (SUC m)
Goal:  [∀m. m < n ⇒ ¬depth x t1 m, x ≠ a, ¬mem x t2, mem x t1, depth x t1 n]
|- ∃n. depth x (Nd a t1 t2) n

Number: 344
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- SUC x < SUC y ⇔ x < y
 []
|- (∀x t1 t2. depth x (Nd x t1 t2) 0) ∧
   (∀m x a t1 t2. depth x t1 m ⇒ depth x (Nd a t1 t2) (SUC m)) ∧
   ∀m x a t1 t2. depth x t2 m ⇒ depth x (Nd a t1 t2) (SUC m)
Goal: 
[∀n. ¬depth x t2 n, ∀m. m < n ⇒ ¬depth x t1 m,
 ∀m'. m' < SUC m ⇒ ¬depth x (Nd a t1 t2) m', x ≠ a, ¬mem x t2, n < m,
 mem x t1, depth x t1 m, depth x t1 n] |- F

Number: 361
Status: Parsing failed
Info: polymorph lambda-lift num proof 
Thm list: 
 []
|- ∀x t.
     mindepth x t =
     if mem x t then SOME (LEAST n. depth x t n) else NONE
Goal:  [] |- ∀x t. mem x t ⇒ ∃n. mindepth x t = SOME n

Number: 362
Status: Unknown
Info: polymorph num proof 
Thm list: 
 [] |- ∀x t. mem x t ⇒ ∃n. depth x t n
Goal:  [mem x t] |- ∃n. depth x t n

Number: 363
Status: Parsing failed
Info: polymorph num proof 
Thm list: 
 [] |- ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l)
Goal:  [f e = SOME n, MEM e l] |- ∃i. i < LENGTH l ∧ (f (EL i l) = SOME n)

Number: 375
Status: Parsing failed
Info: polymorph num proof 
Thm list: 
 [] |- ¬(x < y ∧ y ≤ x)
 [] |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
 [] |- ∀x. SOME x ≠ NONE
Goal: 
[∀i'.
   i' < LENGTH l ⇒
   (f (EL i' l) = NONE) ∨
   ∃d'. (f (EL i' l) = SOME d') ∧ m ≤ d' ∧ (i' < i ⇒ m < d'),
 ∀i.
   i < LENGTH l ⇒
   (f (EL i l) = NONE) ∨
   ∃d'. (f (EL i l) = SOME d') ∧ n ≤ d' ∧ (i < j ⇒ n < d'),
 i < LENGTH l, j < LENGTH l, m < n, f (EL i l) = SOME m,
 f (EL j l) = SOME n] |- F

Number: 376
Status: Parsing failed
Info: polymorph num proof 
Thm list: 
 [] |- ¬(x < y ∧ y ≤ x)
 [] |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
 [] |- ∀x. SOME x ≠ NONE
Goal: 
[∀i'.
   i' < LENGTH l ⇒
   (f (EL i' l) = NONE) ∨
   ∃d'. (f (EL i' l) = SOME d') ∧ m ≤ d' ∧ (i' < i ⇒ m < d'),
 ∀i.
   i < LENGTH l ⇒
   (f (EL i l) = NONE) ∨
   ∃d'. (f (EL i l) = SOME d') ∧ n ≤ d' ∧ (i < j ⇒ n < d'),
 i < LENGTH l, j < LENGTH l, n < m, f (EL i l) = SOME m,
 f (EL j l) = SOME n] |- F

Number: 377
Status: Parsing failed
Info: polymorph num proof 
Thm list: 
 [] |- ¬(x < y ∧ y ≤ x)
 [] |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
 [] |- ∀x. SOME x ≠ NONE
Goal: 
[∀i'.
   i' < LENGTH l ⇒
   (f (EL i' l) = NONE) ∨
   ∃d'. (f (EL i' l) = SOME d') ∧ m ≤ d' ∧ (i' < i ⇒ m < d'),
 ∀i.
   i < LENGTH l ⇒
   (f (EL i l) = NONE) ∨
   ∃d'. (f (EL i l) = SOME d') ∧ n ≤ d' ∧ (i < j ⇒ n < d'), i < j,
 i < LENGTH l, j < LENGTH l, f (EL i l) = SOME m, f (EL j l) = SOME n]
|- F

Number: 378
Status: Parsing failed
Info: polymorph num proof 
Thm list: 
 [] |- ¬(x < y ∧ y ≤ x)
 [] |- ∀x y. (SOME x = SOME y) ⇔ (x = y)
 [] |- ∀x. SOME x ≠ NONE
Goal: 
[∀i'.
   i' < LENGTH l ⇒
   (f (EL i' l) = NONE) ∨
   ∃d'. (f (EL i' l) = SOME d') ∧ m ≤ d' ∧ (i' < i ⇒ m < d'),
 ∀i.
   i < LENGTH l ⇒
   (f (EL i l) = NONE) ∨
   ∃d'. (f (EL i l) = SOME d') ∧ n ≤ d' ∧ (i < j ⇒ n < d'),
 i < LENGTH l, j < i, j < LENGTH l, f (EL i l) = SOME m,
 f (EL j l) = SOME n] |- F

Number: 380
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- EXISTS (λe. ∃n. f e = SOME n) l ⇒ ∃i m. is_mmindex f l i m
Goal: 
[∀tlist' x'.
   (@i. ∃d. is_mmindex (mindepth x') tlist' i d) <
   (@i. ∃d. is_mmindex (mindepth x) tlist i d) ⇒
   (THE
      (mindepth x
         (EL (@i. ∃d. is_mmindex (mindepth x) tlist i d) tlist)) =
    THE
      (mindepth x'
         (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist'))) ∧
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀tlist' x'.
   THE
     (mindepth x'
        (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist')) <
   THE
     (mindepth x
        (EL (@i. ∃d. is_mmindex (mindepth x) tlist i d) tlist)) ⇒
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'), EXISTS (mem x) tlist,
 EXISTS (λe. ∃n. mindepth x e = SOME n) tlist]
|- ∃i d. is_mmindex (mindepth x) tlist i d

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 385
Status: undefined
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀f l n d.
     is_mmindex f l n d ⇔
     n < LENGTH l ∧ (f (EL n l) = SOME d) ∧
     ∀i.
       i < LENGTH l ⇒
       (f (EL i l) = NONE) ∨
       ∃d'. (f (EL i l) = SOME d') ∧ d ≤ d' ∧ (i < n ⇒ d < d')
 [] |- (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)
 [] |- SUC x < SUC y ⇔ x < y
Goal: 
[∀tlist' x'.
   THE
     (mindepth x'
        (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist')) < d ⇒
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀j n'.
   is_mmindex (mindepth x) (t ++ [t1; t2]) j n' ⇔ (j = n) ∧ (n' = d),
 ∀j n'.
   is_mmindex (mindepth x) (Nd a t1 t2::t) j n' ⇔
   (j = SUC n) ∧ (n' = d), x ≠ a,
 mindepth x (EL (SUC n) (Nd a t1 t2::t)) = SOME d,
 EXISTS (mem x) (Nd a t1 t2::t),
 EXISTS (λe. ∃n. mindepth x e = SOME n) (Nd a t1 t2::t)] |- n < LENGTH t

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 386
Status: undefined
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x t n. depth x t n ⇒ mem x t
 [] |- (mindepth x t = SOME n) ⇒ depth x t n
Goal: 
[T,
 ∀tlist' x'.
   THE
     (mindepth x'
        (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist')) <
   SUC z ⇒
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀j n.
   is_mmindex (mindepth x) (Nd a t1 t2::t) j n ⇔ (j = 0) ∧ (n = SUC z),
 x ≠ a, d = SUC z, MIN x' x'' = z, mindepth x t1 = SOME x',
 mindepth x t2 = SOME x''] |- mem x t1 ∧ mem x t2

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 387
Status: undefined
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x t n. depth x t n ⇒ mem x t
 [] |- (mindepth x t = SOME n) ⇒ depth x t n
Goal: 
[T,
 ∀tlist' x'.
   THE
     (mindepth x'
        (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist')) <
   SUC z ⇒
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀j n.
   is_mmindex (mindepth x) (Nd a t1 t2::t) j n ⇔ (j = 0) ∧ (n = SUC z),
 x ≠ a, d = SUC z, x' = z, mindepth x t1 = SOME x',
 mindepth x t2 = NONE] |- mem x t1

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 388
Status: undefined
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x t n. depth x t n ⇒ mem x t
 [] |- (mindepth x t = SOME n) ⇒ depth x t n
Goal: 
[T,
 ∀tlist' x'.
   THE
     (mindepth x'
        (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist')) <
   SUC z ⇒
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀j n.
   is_mmindex (mindepth x) (Nd a t1 t2::t) j n ⇔ (j = 0) ∧ (n = SUC z),
 x ≠ a, d = SUC z, x' = z, mindepth x t1 = NONE,
 mindepth x t2 = SOME x'] |- mem x t2

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 389
Status: undefined
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- (f x = NONE) ⇒ (is_mmindex f (x::t) (SUC j) n ⇔ is_mmindex f t j n)
 []
|- (mindepth x Lf = NONE) ∧
   (mindepth x (Nd a t1 t2) =
    if x = a then SOME 0
    else OPTION_MAP SUC (optmin (mindepth x t1) (mindepth x t2)))
Goal: 
[∀tlist' x'.
   (@i. ∃d. is_mmindex (mindepth x') tlist' i d) < i ⇒
   (d =
    THE
      (mindepth x'
         (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist'))) ∧
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀tlist' x'.
   THE
     (mindepth x'
        (EL (@i. ∃d. is_mmindex (mindepth x') tlist' i d) tlist')) < d ⇒
   EXISTS (mem x') tlist' ⇒
   exists ($= x') (bf_flatten tlist'),
 ∀j n. is_mmindex (mindepth x) (Lf::t) j n ⇔ (j = i) ∧ (n = d),
 i = SUC i0, mindepth x (EL i (Lf::t)) = SOME d, EXISTS (mem x) (Lf::t),
 EXISTS (λe. ∃n. mindepth x e = SOME n) (Lf::t),
 is_mmindex (mindepth x) (Lf::t) (SUC i0) d]
|- is_mmindex (mindepth x) t i0 d

Number: 399
Status: Time Out
Info: num proof 
Thm list: 
 [] |- ∀a b. (BRANCHING_BIT a b = 0) ⇔ (ODD a ⇔ EVEN b) ∨ (a = b)
 [] |- ∀a b. (BRANCHING_BIT a b = 0) ⇔ (ODD b ⇔ EVEN a) ∨ (a = b)
Goal:  [0 = BRANCHING_BIT a b] |- BRANCHING_BIT a b = BRANCHING_BIT b a

Number: 405
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 [] |- ∀a b. MOD_2EXP_EQ (BRANCHING_BIT a b) a b
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀t k d. t |+ (k,d) ≠ <{}>
 [] |- MOD_2EXP x n < 2 ** x
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT q n0) q, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)),
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- EVERY_LEAF
     (λk d.
        MOD_2EXP_EQ (BRANCHING_BIT q n0) k q ∧
        BIT (BRANCHING_BIT q n0) k) t'

Number: 406
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 [] |- ∀a b. MOD_2EXP_EQ (BRANCHING_BIT a b) a b
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀t k d. t |+ (k,d) ≠ <{}>
 [] |- MOD_2EXP x n < 2 ** x
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT q n0) q, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)),
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- EVERY_LEAF
     (λk d.
        MOD_2EXP_EQ (BRANCHING_BIT q n0) k q ∧
        BIT (BRANCHING_BIT q n0) k) t

Number: 408
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 [] |- ∀a b. MOD_2EXP_EQ (BRANCHING_BIT a b) a b
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀t k d. t |+ (k,d) ≠ <{}>
 [] |- MOD_2EXP x n < 2 ** x
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬MOD_2EXP_EQ n q n0,
 n0 < 2 ** n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT (BRANCHING_BIT q n0) q,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- EVERY_LEAF
     (λk d.
        MOD_2EXP_EQ (BRANCHING_BIT q n0) k q ∧
        ¬BIT (BRANCHING_BIT q n0) k) t'

Number: 409
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 [] |- ∀a b. MOD_2EXP_EQ (BRANCHING_BIT a b) a b
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀t k d. t |+ (k,d) ≠ <{}>
 [] |- MOD_2EXP x n < 2 ** x
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬MOD_2EXP_EQ n q n0,
 n0 < 2 ** n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT (BRANCHING_BIT q n0) q,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- EVERY_LEAF
     (λk d.
        MOD_2EXP_EQ (BRANCHING_BIT q n0) k q ∧
        ¬BIT (BRANCHING_BIT q n0) k) t

Number: 431
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n k,
 ¬BIT (BRANCHING_BIT q n0) q, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT (BRANCHING_BIT q n0) n0,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q] |- BIT (BRANCHING_BIT q n0) k

Number: 432
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n k,
 ¬BIT (BRANCHING_BIT q n0) q, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT (BRANCHING_BIT q n0) n0,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q]
|- MOD_2EXP_EQ (BRANCHING_BIT q n0) k q

Number: 433
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT q n0) q, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT n k,
 BIT (BRANCHING_BIT q n0) n0,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q] |- BIT (BRANCHING_BIT q n0) k

Number: 434
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT q n0) q, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT n k,
 BIT (BRANCHING_BIT q n0) n0,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q]
|- MOD_2EXP_EQ (BRANCHING_BIT q n0) k q

Number: 435
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n k,
 ¬BIT (BRANCHING_BIT q n0) n0, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT (BRANCHING_BIT q n0) q,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q] |- ¬BIT (BRANCHING_BIT q n0) k

Number: 436
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n k,
 ¬BIT (BRANCHING_BIT q n0) n0, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT (BRANCHING_BIT q n0) q,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q]
|- MOD_2EXP_EQ (BRANCHING_BIT q n0) k q

Number: 437
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT q n0) n0, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT n k,
 BIT (BRANCHING_BIT q n0) q,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q] |- ¬BIT (BRANCHING_BIT q n0) k

Number: 438
Status: Time Out
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀m n a b. n ≤ m ∧ MOD_2EXP_EQ m a b ⇒ MOD_2EXP_EQ n a b
 [] |- a < b ⇒ a ≤ b
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
Goal: 
[IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT q n0) n0, ¬MOD_2EXP_EQ n q n0, n0 < 2 ** n,
 BRANCHING_BIT q n0 < n, IS_PTREE t ⇒ IS_PTREE (t |+ (q,r)),
 IS_PTREE t' ⇒ IS_PTREE (t' |+ (q,r)), BIT n k,
 BIT (BRANCHING_BIT q n0) q,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0,
 MOD_2EXP_EQ (BRANCHING_BIT q n0) n0 q]
|- MOD_2EXP_EQ (BRANCHING_BIT q n0) k q

Number: 439
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀p m l r.
     p < 2 ** m ∧ ¬((l = <{}>) ∧ (r = <{}>)) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r ∧ IS_PTREE l ∧
     IS_PTREE r ⇒
     IS_PTREE (BRANCH (p,m,l,r))
 [] |- ∀P t k. EVERY_LEAF P t ⇒ EVERY_LEAF P (t \\ k)
Goal: 
[∀k. IS_PTREE t ⇒ IS_PTREE (t \\ k),
 ∀k. IS_PTREE t' ⇒ IS_PTREE (t' \\ k), IS_PTREE t, IS_PTREE t',
 t ≠ <{}>, t' ≠ <{}>, ¬BIT n k, n0 < 2 ** n,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0]
|- IS_PTREE (BRANCH (n0,n,t,t' \\ k))

Number: 440
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀p m l r.
     p < 2 ** m ∧ ¬((l = <{}>) ∧ (r = <{}>)) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r ∧ IS_PTREE l ∧
     IS_PTREE r ⇒
     IS_PTREE (BRANCH (p,m,l,r))
 [] |- ∀P t k. EVERY_LEAF P t ⇒ EVERY_LEAF P (t \\ k)
Goal: 
[∀k. IS_PTREE t ⇒ IS_PTREE (t \\ k),
 ∀k. IS_PTREE t' ⇒ IS_PTREE (t' \\ k), IS_PTREE t, IS_PTREE t',
 t ≠ <{}>, t' ≠ <{}>, n0 < 2 ** n, BIT n k,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0]
|- IS_PTREE (BRANCH (n0,n,t \\ k,t'))

Number: 444
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ BRANCHING_BIT a b < n
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ a ≠ b
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
Goal: 
[∀k d j.
   IS_PTREE t ⇒ ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j),
 ∀k d j.
   IS_PTREE t' ⇒ ((t' |+ (k,d)) ' j = if k = j then SOME d else t' ' j),
 IS_PTREE t, IS_PTREE t', k ≠ j, t ≠ <{}>, t' ≠ <{}>, ¬BIT n j,
 ¬BIT (BRANCHING_BIT k n0) j, ¬BIT (BRANCHING_BIT k n0) k,
 ¬MOD_2EXP_EQ n k n0, n0 < 2 ** n,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t] |- NONE = t' ' j

Number: 445
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ BRANCHING_BIT a b < n
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ a ≠ b
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
Goal: 
[∀k d j.
   IS_PTREE t ⇒ ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j),
 ∀k d j.
   IS_PTREE t' ⇒ ((t' |+ (k,d)) ' j = if k = j then SOME d else t' ' j),
 IS_PTREE t, IS_PTREE t', k ≠ j, t ≠ <{}>, t' ≠ <{}>,
 ¬BIT (BRANCHING_BIT k n0) j, ¬BIT (BRANCHING_BIT k n0) k,
 ¬MOD_2EXP_EQ n k n0, n0 < 2 ** n, BIT n j,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t] |- NONE = t ' j

Number: 446
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ BRANCHING_BIT a b < n
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ a ≠ b
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
Goal: 
[∀k d j.
   IS_PTREE t ⇒ ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j),
 ∀k d j.
   IS_PTREE t' ⇒ ((t' |+ (k,d)) ' j = if k = j then SOME d else t' ' j),
 IS_PTREE t, IS_PTREE t', k ≠ j, t ≠ <{}>, t' ≠ <{}>, ¬BIT n j,
 ¬MOD_2EXP_EQ n k n0, n0 < 2 ** n, BIT (BRANCHING_BIT k n0) j,
 BIT (BRANCHING_BIT k n0) k,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t] |- NONE = t' ' j

Number: 447
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ BRANCHING_BIT a b < n
 []
|- ∀a b. a ≠ b ⇒ (BIT (BRANCHING_BIT a b) a ⇎ BIT (BRANCHING_BIT a b) b)
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
 [] |- ∀n a b. ¬MOD_2EXP_EQ n a b ⇒ a ≠ b
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
Goal: 
[∀k d j.
   IS_PTREE t ⇒ ((t |+ (k,d)) ' j = if k = j then SOME d else t ' j),
 ∀k d j.
   IS_PTREE t' ⇒ ((t' |+ (k,d)) ' j = if k = j then SOME d else t' ' j),
 IS_PTREE t, IS_PTREE t', k ≠ j, t ≠ <{}>, t' ≠ <{}>,
 ¬MOD_2EXP_EQ n k n0, n0 < 2 ** n, BIT n j, BIT (BRANCHING_BIT k n0) j,
 BIT (BRANCHING_BIT k n0) k,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t] |- NONE = t ' j

Number: 450
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
 []
|- (∀k. <{}> ' k = NONE) ∧
   (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
   ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
Goal: 
[∀k j. IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j),
 ∀k j. IS_PTREE t' ⇒ ((t' \\ k) ' j = if k = j then NONE else t' ' j),
 IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n j,
 ¬MOD_2EXP_EQ n j n0, n0 < 2 ** n,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t] |- t' ' j = NONE

Number: 451
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
 []
|- (∀k. <{}> ' k = NONE) ∧
   (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
   ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
Goal: 
[∀k j. IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j),
 ∀k j. IS_PTREE t' ⇒ ((t' \\ k) ' j = if k = j then NONE else t' ' j),
 IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬MOD_2EXP_EQ n j n0,
 n0 < 2 ** n, BIT n j,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t] |- t ' j = NONE

Number: 452
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
 []
|- (∀k. <{}> ' k = NONE) ∧
   (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
   ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
Goal: 
[∀k j. IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j),
 ∀k j. IS_PTREE t' ⇒ ((t' \\ k) ' j = if k = j then NONE else t' ' j),
 IS_PTREE t, IS_PTREE t', k ≠ j, t ≠ <{}>, t' ≠ <{}>, ¬BIT n j,
 ¬BIT n k, n0 < 2 ** n, t' \\ k = <{}>,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0]
|- t ' j = t' ' j

Number: 453
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
 []
|- (∀k. <{}> ' k = NONE) ∧
   (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
   ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
Goal: 
[∀k j. IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j),
 ∀k j. IS_PTREE t' ⇒ ((t' \\ k) ' j = if k = j then NONE else t' ' j),
 IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n j, n0 < 2 ** n,
 t' \\ j = <{}>, EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n j n0]
|- t ' j = NONE

Number: 454
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
 []
|- (∀k. <{}> ' k = NONE) ∧
   (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
   ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
Goal: 
[∀k j. IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j),
 ∀k j. IS_PTREE t' ⇒ ((t' \\ k) ' j = if k = j then NONE else t' ' j),
 IS_PTREE t, IS_PTREE t', k ≠ j, t ≠ <{}>, t' ≠ <{}>, n0 < 2 ** n,
 t \\ k = <{}>, BIT n j, BIT n k,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n k n0]
|- t' ' j = t ' j

Number: 455
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     (t ' k = NONE)
 []
|- (∀k. <{}> ' k = NONE) ∧
   (∀k j d. Leaf j d ' k = if k = j then SOME d else NONE) ∧
   ∀r p m l k. Branch p m l r ' k = (if BIT m k then l else r) ' k
Goal: 
[∀k j. IS_PTREE t ⇒ ((t \\ k) ' j = if k = j then NONE else t ' j),
 ∀k j. IS_PTREE t' ⇒ ((t' \\ k) ' j = if k = j then NONE else t' ' j),
 IS_PTREE t, IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, n0 < 2 ** n,
 t \\ j = <{}>, BIT n j,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t, MOD_2EXP_EQ n j n0]
|- t' ' j = NONE

Number: 456
Status: Unknown
Info: higher-order num proof 
Thm list: 
Goal: 
[∀P Q f.
   (∀k d. P k d ⇒ Q k (f d)) ∧ EVERY_LEAF P t ⇒
   EVERY_LEAF Q (TRANSFORM f t),
 ∀P Q f.
   (∀k d. P k d ⇒ Q k (f d)) ∧ EVERY_LEAF P t' ⇒
   EVERY_LEAF Q (TRANSFORM f t'), ∀k d. P k d ⇒ Q k (f d),
 EVERY_LEAF P t, EVERY_LEAF P t'] |- EVERY_LEAF Q (TRANSFORM f t')

Number: 457
Status: Unknown
Info: higher-order num proof 
Thm list: 
Goal: 
[∀P Q f.
   (∀k d. P k d ⇒ Q k (f d)) ∧ EVERY_LEAF P t ⇒
   EVERY_LEAF Q (TRANSFORM f t),
 ∀P Q f.
   (∀k d. P k d ⇒ Q k (f d)) ∧ EVERY_LEAF P t' ⇒
   EVERY_LEAF Q (TRANSFORM f t'), ∀k d. P k d ⇒ Q k (f d),
 EVERY_LEAF P t, EVERY_LEAF P t'] |- EVERY_LEAF Q (TRANSFORM f t)

Number: 458
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀f t.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) (TRANSFORM f t)
 []
|- ∀f t.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) (TRANSFORM f t)
Goal: 
[∀f. IS_PTREE t ⇒ IS_PTREE (TRANSFORM f t),
 ∀f. IS_PTREE t' ⇒ IS_PTREE (TRANSFORM f t'), IS_PTREE t, IS_PTREE t',
 t ≠ <{}>, t' ≠ <{}>, n0 < 2 ** n,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) (TRANSFORM f t')

Number: 459
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀f t.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ⇒
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) (TRANSFORM f t)
 []
|- ∀f t.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ⇒
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) (TRANSFORM f t)
Goal: 
[∀f. IS_PTREE t ⇒ IS_PTREE (TRANSFORM f t),
 ∀f. IS_PTREE t' ⇒ IS_PTREE (TRANSFORM f t'), IS_PTREE t, IS_PTREE t',
 t ≠ <{}>, t' ≠ <{}>, n0 < 2 ** n,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) (TRANSFORM f t)

Number: 460
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) t ⇒
     (t ' k = NONE)
Goal: 
[IS_PTREE l, IS_PTREE r, BIT n p ⇎ BIT n k, l ≠ <{}>, r ≠ <{}>, n < m,
 p < 2 ** m, EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l] |- r ' k = NONE

Number: 461
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇒ ∀x. x < n ⇒ (BIT x a ⇔ BIT x b)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) t ⇒
     (t ' k = NONE)
Goal: 
[IS_PTREE l, IS_PTREE r, BIT n p ⇎ BIT n k, l ≠ <{}>, r ≠ <{}>, n < m,
 p < 2 ** m, EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l] |- l ' k = NONE

Number: 462
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) t ⇒
     (t ' k = NONE)
Goal: 
[IS_PTREE l, IS_PTREE r, l ≠ <{}>, r ≠ <{}>, ¬MOD_2EXP_EQ m k p,
 p < 2 ** m, EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l] |- r ' k = NONE

Number: 463
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) t ⇒
     (t ' k = NONE)
Goal: 
[IS_PTREE l, IS_PTREE r, l ≠ <{}>, r ≠ <{}>, ¬MOD_2EXP_EQ m k p,
 p < 2 ** m, EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l] |- l ' k = NONE

Number: 464
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ∧
     IS_SOME (t ' k) ⇒
     MOD_2EXP_EQ n k n0 ∧ BIT n k
 []
|- ∀t k.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ∧
     IS_SOME (t ' k) ⇒
     MOD_2EXP_EQ n k n0 ∧ ¬BIT n k
Goal: 
[IS_PTREE l, IS_PTREE r, IS_PTREE r', IS_PTREE (Branch p m l r),
 IS_PTREE (Branch p m l r'), l ≠ <{}>, r ≠ <{}>, r' ≠ <{}>, n0 < 2 ** n,
 p < 2 ** m, IS_PTREE (Branch p m l r) ⇒ ∃k. ¬BIT m k ∧ IS_SOME (r ' k),
 IS_PTREE (Branch p m l r') ⇒ ∃k. ¬BIT m k ∧ IS_SOME (r' ' k),
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) (Branch n0 n r r'),
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) r',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) r]
|- ∃k. ¬BIT m k ∧ IS_SOME ((if BIT n k then r else r') ' k)

Number: 465
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t ∧
     IS_SOME (t ' k) ⇒
     MOD_2EXP_EQ n k n0 ∧ BIT n k
 []
|- ∀t k.
     EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t ∧
     IS_SOME (t ' k) ⇒
     MOD_2EXP_EQ n k n0 ∧ ¬BIT n k
Goal: 
[IS_PTREE l, IS_PTREE l', IS_PTREE r, IS_PTREE (Branch p m l r),
 IS_PTREE (Branch p m l' r), l ≠ <{}>, l' ≠ <{}>, r ≠ <{}>, n0 < 2 ** n,
 p < 2 ** m, IS_PTREE (Branch p m l r) ⇒ ∃k. BIT m k ∧ IS_SOME (l ' k),
 IS_PTREE (Branch p m l' r) ⇒ ∃k. BIT m k ∧ IS_SOME (l' ' k),
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) (Branch n0 n l l'),
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) l',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) l]
|- ∃k. BIT m k ∧ IS_SOME ((if BIT n k then l else l') ' k)

Number: 467
Status: Parsing failed
Info: higher-order num proof 
Thm list: 
Goal: 
[∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀k.
   ¬IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
   ¬IS_SOME ((if BIT n k then t2 else t2') ' k) ∨
   (IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
    IS_SOME ((if BIT n k then t2 else t2') ' k)) ∧
   (THE ((if BIT n' k then t1 else t1') ' k) =
    THE ((if BIT n k then t2 else t2') ' k)),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0 n t2 t2'), IS_PTREE (Branch n0' n' t1 t1'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), ¬(BIT n n0' ⇎ BIT n k'), ¬BIT n k'', ¬BIT n' k''',
 BIT n k, BIT n' k'] |- ¬(n < n')

Number: 468
Status: Parsing failed
Info: higher-order num proof 
Thm list: 
Goal: 
[∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀k.
   ¬IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
   ¬IS_SOME ((if BIT n k then t2 else t2') ' k) ∨
   (IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
    IS_SOME ((if BIT n k then t2 else t2') ' k)) ∧
   (THE ((if BIT n' k then t1 else t1') ' k) =
    THE ((if BIT n k then t2 else t2') ' k)),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0 n t2 t2'), IS_PTREE (Branch n0' n' t1 t1'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), BIT n n0' ⇎ BIT n k', ¬BIT n k'', ¬BIT n' k''',
 BIT n k, BIT n' k'] |- ¬(n < n')

Number: 469
Status: Parsing failed
Info: higher-order num proof 
Thm list: 
 [] |- ∀n a b. a < 2 ** n ∧ b < 2 ** n ∧ MOD_2EXP_EQ n a b ⇒ (a = b)
 []
|- ∀n a b c. MOD_2EXP_EQ n a b ∧ MOD_2EXP_EQ n b c ⇒ MOD_2EXP_EQ n a c
 [] |- ∀n a b. MOD_2EXP_EQ n a b ⇔ MOD_2EXP_EQ n b a
Goal: 
[∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀k.
   ¬IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
   ¬IS_SOME ((if BIT n k then t2 else t2') ' k) ∨
   (IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
    IS_SOME ((if BIT n k then t2 else t2') ' k)) ∧
   (THE ((if BIT n' k then t1 else t1') ' k) =
    THE ((if BIT n k then t2 else t2') ' k)),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0 n t2 t2'), IS_PTREE (Branch n0' n' t1 t1'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), ¬(n < n'), ¬(n' < n), ¬BIT n k'', ¬BIT n' k''',
 n0 < 2 ** n, n0' < 2 ** n, n = n', BIT n k, BIT n' k'] |- n0 = n0'

Number: 470
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- (IS_PTREE <{}> ⇔ T) ∧ (∀k d. IS_PTREE (Leaf k d) ⇔ T) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇔
     p < 2 ** m ∧ IS_PTREE l ∧ IS_PTREE r ∧ l ≠ <{}> ∧ r ≠ <{}> ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r
Goal: 
[∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀k.
   ¬IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
   ¬IS_SOME ((if BIT n k then t2 else t2') ' k) ∨
   (IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
    IS_SOME ((if BIT n k then t2 else t2') ' k)) ∧
   (THE ((if BIT n' k then t1 else t1') ' k) =
    THE ((if BIT n k then t2 else t2') ' k)),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0 n t2 t2'), IS_PTREE (Branch n0' n' t1 t1'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), ¬(n < n'), ¬(n' < n), ¬BIT n k'', ¬BIT n' k''',
 n0 < 2 ** n, n0' < 2 ** n, n = n', n0 = n0', BIT n k, BIT n' k']
|- (t1 = t2) ⇔ ∀k. t1 ' k = t2 ' k

Number: 471
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- (IS_PTREE <{}> ⇔ T) ∧ (∀k d. IS_PTREE (Leaf k d) ⇔ T) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇔
     p < 2 ** m ∧ IS_PTREE l ∧ IS_PTREE r ∧ l ≠ <{}> ∧ r ≠ <{}> ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r
Goal: 
[∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n k n0 ⇒ ¬IS_SOME (t2' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n'. n' < n ⇒ ∀k. (BIT n' n0 ⇎ BIT n' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀k.
   ¬IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
   ¬IS_SOME ((if BIT n k then t2 else t2') ' k) ∨
   (IS_SOME ((if BIT n' k then t1 else t1') ' k) ∧
    IS_SOME ((if BIT n k then t2 else t2') ' k)) ∧
   (THE ((if BIT n' k then t1 else t1') ' k) =
    THE ((if BIT n k then t2 else t2') ' k)),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0 n t2 t2'), IS_PTREE (Branch n0' n' t1 t1'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), ¬(n < n'), ¬(n' < n), ¬BIT n k'', ¬BIT n' k''',
 n0 < 2 ** n, n0' < 2 ** n, (t1 = t2) ⇔ ∀k. t1 ' k = t2 ' k, n = n',
 n0 = n0', BIT n k, BIT n' k'] |- (t1' = t2') ⇔ ∀k. t1' ' k = t2' ' k

Number: 472
Status: Parsing failed
Info: higher-order num proof 
Thm list: 
Goal: 
[T,
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k''''.
   (if BIT n' k'''' then t1 else t1') ' k'''' =
   (if BIT n' k'''' then t2 else t2') ' k'''',
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0' n' t1 t1'), IS_PTREE (Branch n0' n' t2 t2'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), ¬(n' < n'), ¬BIT n' k'', ¬BIT n' k''',
 ¬BIT n' k'''', n0' < 2 ** n, (t1 = t2) ⇔ ∀k. t1 ' k = t2 ' k,
 (t1' = t2') ⇔ ∀k. t1' ' k = t2' ' k, n = n', n0 = n0', BIT n' k,
 BIT n' k'] |- t1' ' k'''' = t2' ' k''''

Number: 473
Status: Parsing failed
Info: higher-order num proof 
Thm list: 
Goal: 
[T,
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2 ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2 ' k) ⇔ (Branch n0 n t1 t1' = t2)),
 ∀n n0.
   IS_PTREE (Branch n0 n t1 t1') ∧ IS_PTREE t2' ⇒
   ((∀k. Branch n0 n t1 t1' ' k = t2' ' k) ⇔
    (Branch n0 n t1 t1' = t2')),
 ∀k''''.
   (if BIT n' k'''' then t1 else t1') ' k'''' =
   (if BIT n' k'''' then t2 else t2') ' k'''',
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t1' ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t2 ' k),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ ¬IS_SOME (t2' ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1 ' k),
 ∀n. n < n' ⇒ ∀k. (BIT n n0' ⇎ BIT n k) ⇒ ¬IS_SOME (t1' ' k),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ ¬IS_SOME (t2 ' k),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ ¬IS_SOME (t2' ' k),
 ∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0' n' t1 t1'), IS_PTREE (Branch n0' n' t2 t2'),
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), ¬(n' < n'), ¬BIT n' k'', ¬BIT n' k''',
 n0' < 2 ** n, (t1 = t2) ⇔ ∀k. t1 ' k = t2 ' k,
 (t1' = t2') ⇔ ∀k. t1' ' k = t2' ' k, n = n', n0 = n0', BIT n' k,
 BIT n' k', BIT n' k''''] |- t1 ' k'''' = t2 ' k''''

Number: 474
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t ⇒
     (t ' k = NONE)
Goal: 
[T,
 ∀n'' n0''.
   n0'' < 2 ** n'' ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ BIT n'' k) t1 ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ ¬BIT n'' k) t1' ⇒
   ((∀k. Branch n0'' n'' t1 t1' ' k = t2 ' k) ⇔
    (Branch n0'' n'' t1 t1' = t2)),
 ∀n'' n0''.
   n0'' < 2 ** n'' ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ BIT n'' k) t1 ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ ¬BIT n'' k) t1' ⇒
   ((∀k. Branch n0'' n'' t1 t1' ' k = t2' ' k) ⇔
    (Branch n0'' n'' t1 t1' = t2')),
 ∀k''''.
   (if BIT n' k'''' then t1 else t1') ' k'''' =
   (if BIT n' k'''' then t2 else t2') ' k'''',
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t1 ' k = NONE),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t1' ' k = NONE),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t2 ' k = NONE),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t2' ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t1 ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t1' ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t2 ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t2' ' k = NONE),
 ∀t2''. IS_PTREE t2'' ⇒ ((∀k. t1 ' k = t2'' ' k) ⇔ (t1 = t2'')),
 ∀t2''. IS_PTREE t2'' ⇒ ((∀k. t1' ' k = t2'' ' k) ⇔ (t1' = t2'')),
 IS_PTREE t1, IS_PTREE t1', IS_PTREE t2, IS_PTREE t2',
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), t1 ≠ <{}>, t1' ≠ <{}>, t2 ≠ <{}>, t2' ≠ <{}>,
 ¬BIT n' k'', ¬BIT n' k''', n0' < 2 ** n, n0' < 2 ** n',
 (t1 = t2) ⇔ ∀k. t1 ' k = t2 ' k, (t1' = t2') ⇔ ∀k. t1' ' k = t2' ' k,
 n = n', n0 = n0', BIT n' k, BIT n' k', BIT n' k'''',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t1',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t2',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t1,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t2]
|- t1' ' k'''' = t2' ' k''''

Number: 475
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t ⇒
     (t ' k = NONE)
Goal: 
[T,
 ∀n'' n0''.
   n0'' < 2 ** n'' ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ BIT n'' k) t1 ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ ¬BIT n'' k) t1' ⇒
   ((∀k. Branch n0'' n'' t1 t1' ' k = t2 ' k) ⇔
    (Branch n0'' n'' t1 t1' = t2)),
 ∀n'' n0''.
   n0'' < 2 ** n'' ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ BIT n'' k) t1 ∧
   EVERY_LEAF (λk d. MOD_2EXP_EQ n'' k n0'' ∧ ¬BIT n'' k) t1' ⇒
   ((∀k. Branch n0'' n'' t1 t1' ' k = t2' ' k) ⇔
    (Branch n0'' n'' t1 t1' = t2')),
 ∀k''''.
   (if BIT n' k'''' then t1 else t1') ' k'''' =
   (if BIT n' k'''' then t2 else t2') ' k'''',
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t1 ' k = NONE),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t1' ' k = NONE),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t2 ' k = NONE),
 ∀k. ¬MOD_2EXP_EQ n' k n0' ⇒ (t2' ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t1 ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t1' ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t2 ' k = NONE),
 ∀n''. n'' < n' ⇒ ∀k. (BIT n'' n0' ⇎ BIT n'' k) ⇒ (t2' ' k = NONE),
 ∀t2''. IS_PTREE t2'' ⇒ ((∀k. t1 ' k = t2'' ' k) ⇔ (t1 = t2'')),
 ∀t2''. IS_PTREE t2'' ⇒ ((∀k. t1' ' k = t2'' ' k) ⇔ (t1' = t2'')),
 IS_PTREE t1, IS_PTREE t1', IS_PTREE t2, IS_PTREE t2',
 IS_SOME (t1 ' k'), IS_SOME (t1' ' k'''), IS_SOME (t2 ' k),
 IS_SOME (t2' ' k''), t1 ≠ <{}>, t1' ≠ <{}>, t2 ≠ <{}>, t2' ≠ <{}>,
 ¬BIT n' k'', ¬BIT n' k''', ¬BIT n' k'''', n0' < 2 ** n, n0' < 2 ** n',
 (t1 = t2) ⇔ ∀k. t1 ' k = t2 ' k, (t1' = t2') ⇔ ∀k. t1' ' k = t2' ' k,
 n = n', n0 = n0', BIT n' k, BIT n' k',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t1',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t2',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t1,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t2]
|- t1 ' k'''' = t2 ' k''''

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Number: 476
Status: undefined
Info: polymorph 
Thm list: 
 []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Goal: 
[∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Leaf n a), IS_PTREE (Branch n0 n' t1 t1')]
|- ∃k.
     (IS_SOME ((if BIT n' k then t1 else t1') ' k) ∨ (n = k)) ∧
     ((¬IS_SOME ((if BIT n' k then t1 else t1') ' k) ∨ n ≠ k) ∨
      THE ((if BIT n' k then t1 else t1') ' k) ≠
      THE (if k = n then SOME a else NONE))

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Number: 477
Status: undefined
Info: polymorph 
Thm list: 
 []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Goal: 
[∀t2. IS_PTREE t1 ∧ IS_PTREE t2 ⇒ ((∀k. t1 ' k = t2 ' k) ⇔ (t1 = t2)),
 ∀t2.
   IS_PTREE t1' ∧ IS_PTREE t2 ⇒ ((∀k. t1' ' k = t2 ' k) ⇔ (t1' = t2)),
 IS_PTREE (Branch n0 n t1 t1')]
|- ∃k. IS_SOME ((if BIT n k then t1 else t1') ' k)

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Number: 478
Status: undefined
Info: polymorph 
Thm list: 
 []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Goal: 
[∀n a.
   IS_PTREE (Leaf n a) ∧ IS_PTREE t2 ⇒
   ((∀k. Leaf n a ' k = t2 ' k) ⇔ (Leaf n a = t2)),
 ∀n a.
   IS_PTREE (Leaf n a) ∧ IS_PTREE t2' ⇒
   ((∀k. Leaf n a ' k = t2' ' k) ⇔ (Leaf n a = t2')),
 IS_PTREE (Leaf n' a), IS_PTREE (Branch n0 n t2 t2')]
|- ∃k.
     ((n' = k) ∨ IS_SOME ((if BIT n k then t2 else t2') ' k)) ∧
     ((n' ≠ k ∨ ¬IS_SOME ((if BIT n k then t2 else t2') ' k)) ∨
      THE (if k = n' then SOME a else NONE) ≠
      THE ((if BIT n k then t2 else t2') ' k))

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Number: 479
Status: undefined
Info: polymorph 
Thm list: 
 []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
 [] |- ∀x. THE (SOME x) = x
Goal:  [IS_PTREE (Leaf n a), IS_PTREE (Leaf n' a')]
|- (∀k.
      n' ≠ k ∧ n ≠ k ∨
      ((n' = k) ∧ (n = k)) ∧
      (THE (if k = n' then SOME a' else NONE) =
       THE (if k = n then SOME a else NONE))) ⇔ (n' = n) ∧ (a' = a)

structure: monomorph - monomorph function: monomorph_pb - monomorph_thm_pb message:  -  []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Number: 480
Status: undefined
Info: polymorph 
Thm list: 
 []
|- (∀k. ¬IS_SOME (<{}> ' k)) ∧
   (∀k j b. IS_SOME (Leaf j b ' k) ⇔ (j = k)) ∧
   ∀p m l r.
     IS_PTREE (Branch p m l r) ⇒
     (∃k. BIT m k ∧ IS_SOME (l ' k)) ∧
     (∃k. ¬BIT m k ∧ IS_SOME (r ' k)) ∧
     ∀k n.
       ¬MOD_2EXP_EQ m k p ∨ n < m ∧ (BIT n p ⇎ BIT n k) ⇒
       ¬IS_SOME (l ' k) ∧ ¬IS_SOME (r ' k)
Goal: 
[IS_PTREE (Branch n0 n t2 t2'),
 IS_PTREE <{}> ∧ IS_PTREE t2 ⇒ ((∀k. <{}> ' k = t2 ' k) ⇔ (<{}> = t2)),
 IS_PTREE <{}> ∧ IS_PTREE t2' ⇒
 ((∀k. <{}> ' k = t2' ' k) ⇔ (<{}> = t2'))]
|- ∃k. IS_SOME ((if BIT n k then t2 else t2') ' k)

Number: 481
Status: 
Info: polymorph higher-order num proof 
Thm list: 
 [] |- ∀m n. SUC m < SUC n ⇔ m < n
 [] |- (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l)
 [] |- ∀h t. TL (h::t) = t
Goal:  [∀n. n < SUC (LENGTH l) ⇒ ¬P (EL n (h::l)), ¬P h, n < LENGTH l]
|- ¬P (EL n l)

Number: 482
Status: 
Info: polymorph higher-order num proof 
Thm list: 
 [] |- ∀m n. SUC m < SUC n ⇔ m < n
 [] |- (∀l. EL 0 l = HD l) ∧ ∀l n. EL (SUC n) l = EL n (TL l)
 [] |- ∀h t. TL (h::t) = t
Goal:  [∀n. n < LENGTH l ⇒ ¬P (EL n l), ¬P h, SUC n' < SUC (LENGTH l)]
|- ¬P (EL (SUC n') (h::l))

Number: 483
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x. ¬IS_SOME x ⇔ (x = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t ⇒
     (t ' k = NONE)
Goal: 
[∀k. IS_PTREE t ⇒ (MEM k (TRAVERSE t) ⇔ IS_SOME (t ' k)),
 ∀k. IS_PTREE t' ⇒ (MEM k (TRAVERSE t') ⇔ IS_SOME (t' ' k)), IS_PTREE t,
 IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, ¬BIT n k, n0 < 2 ** n,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- IS_SOME (t ' k) ∨ IS_SOME (t' ' k) ⇔ IS_SOME (t' ' k)

Number: 484
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x. ¬IS_SOME x ⇔ (x = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ BIT n' k) t ⇒
     (t ' k = NONE)
 []
|- ∀t k.
     (∀d. ¬(λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) k d) ∧
     EVERY_LEAF (λk d. MOD_2EXP_EQ n' k n0' ∧ ¬BIT n' k) t ⇒
     (t ' k = NONE)
Goal: 
[∀k. IS_PTREE t ⇒ (MEM k (TRAVERSE t) ⇔ IS_SOME (t ' k)),
 ∀k. IS_PTREE t' ⇒ (MEM k (TRAVERSE t') ⇔ IS_SOME (t' ' k)), IS_PTREE t,
 IS_PTREE t', t ≠ <{}>, t' ≠ <{}>, n0 < 2 ** n, BIT n k,
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ ¬BIT n k) t',
 EVERY_LEAF (λk d. MOD_2EXP_EQ n k n0 ∧ BIT n k) t]
|- IS_SOME (t ' k) ∨ IS_SOME (t' ' k) ⇔ IS_SOME (t ' k)

Number: 485
Status: Time Out
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀t k.
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) t ∧
     IS_SOME (t ' k) ⇒
     MOD_2EXP_EQ m k p ∧ BIT m k
 []
|- ∀t k.
     EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) t ∧
     IS_SOME (t ' k) ⇒
     MOD_2EXP_EQ m k p ∧ ¬BIT m k
Goal: 
[IS_PTREE l, IS_PTREE r, IS_SOME (l ' k), IS_SOME (r ' j), l ≠ <{}>,
 r ≠ <{}>, p < 2 ** m,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ ¬BIT m k) r,
 EVERY_LEAF (λk d. MOD_2EXP_EQ m k p ∧ BIT m k) l] |- k ≠ j

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 489
Status: undefined
Info: higher-order num proof 
Thm list: 
Goal: 
[∀x. MEM x l1 ⇔ MEM x l2, ∀x. MEM x l1 ⇒ (FILTER ($= x) l1 = [x]),
 ∀x. MEM x l2 ⇒ (FILTER ($= x) l2 = [x]), MEM x l1]
|- (LENGTH (FILTER ($= x) l1) = LENGTH (FILTER ($= x) l2)) ∧
   ∀x'.
     x' < LENGTH (FILTER ($= x) l1) ⇒
     (EL x' (FILTER ($= x) l1) = EL x' (FILTER ($= x) l2))

structure: printtff - printtff - higherorder function: write_tff - pptff_tff - firstorder_cal message:  -  - $=
Number: 490
Status: undefined
Info: polymorph higher-order num proof 
Thm list: 
 [] |- ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l)
Goal: 
[∀x. MEM x l1 ⇔ MEM x l2, ∀x. MEM x l1 ⇒ (FILTER ($= x) l1 = [x]),
 ∀x. MEM x l2 ⇒ (FILTER ($= x) l2 = [x]),
 ∀l. (∀n. n < LENGTH l ⇒ x ≠ EL n l) ⇔ (FILTER ($= x) l = []),
 x ∉ LIST_TO_SET l1]
|- (LENGTH (FILTER ($= x) l1) = LENGTH (FILTER ($= x) l2)) ∧
   ∀x'.
     x' < LENGTH (FILTER ($= x) l1) ⇒
     (EL x' (FILTER ($= x) l1) = EL x' (FILTER ($= x) l2))

Number: 503
Status: Unknown
Info: polymorph num proof 
Thm list: 
 []
|- ∀t1 t2.
     IS_PTREE t1 ∧ IS_PTREE t2 ⇒
     ((∀k. MEM k (TRAVERSE t1) ⇔ MEM k (TRAVERSE t2)) ⇔
      (TRAVERSE t1 = TRAVERSE t2))
Goal: 
[∀x. MEM x (TRAVERSE t1) ⇔ MEM x (TRAVERSE t2), IS_PTREE t1,
 IS_PTREE t2, QSORT $< (TRAVERSE t1) = QSORT $< (TRAVERSE t2)]
|- TRAVERSE t1 = TRAVERSE t2

Number: 509
Status: Parsing failed
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀l x. MEM x l ⇔ ∃n. n < LENGTH l ∧ (x = EL n l)
Goal: 
[∀k. MEM k l ⇒ (LENGTH (FILTER (λx. x ≠ k) l) = LENGTH l − 1),
 ALL_DISTINCT l, h ∉ LIST_TO_SET l]
|- ∀n. n < LENGTH l ⇒ (λx. x ≠ h) (EL n l)

Number: 510
Status: Time Out
Info: polymorph num proof 
Thm list: 
 []
|- ∀t k d.
     IS_PTREE t ∧ k ∉ LIST_TO_SET (TRAVERSE t) ⇒
     PERM (TRAVERSE (t |+ (k,d))) (k::TRAVERSE t)
 [] |- ∀l1 l2. PERM l1 l2 ⇒ (LENGTH l1 = LENGTH l2)
 [] |- (LENGTH [] = 0) ∧ ∀h t. LENGTH (h::t) = SUC (LENGTH t)
 [] |- ∀m. SUC m = m + 1
Goal:  [IS_PTREE t, k ∉ LIST_TO_SET (TRAVERSE t)]
|- LENGTH (TRAVERSE (t |+ (k,d))) = LENGTH (TRAVERSE t) + 1

Number: 519
Status: Time Out
Info: num proof 
Thm list: 
 [] |- 0 < 256
 [] |- ∀n. 0 < n ⇒ ∀k. (k = k DIV n * n + k MOD n) ∧ k MOD n < n
 [] |- 0 < x ** y ⇔ 0 < x ∨ (y = 0)
Goal:  [256 ≤ n, n DIV 256 ** LOG 256 n = 1]
|- n =
   n DIV 256 ** LOG 256 n * 256 ** LOG 256 n + n MOD 256 ** LOG 256 n

Number: 525
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀e l1 l2. MEM e (l1 ++ l2) ⇔ MEM e l1 ∨ MEM e l2
 [] |- ∀f l1 l2. MAP f (l1 ++ l2) = MAP f l1 ++ MAP f l2
Goal: 
[∀x. MEM x (MAP FST l1) ⇔ MEM x (MAP FST (M ++ N)),
 ∀l2' y.
   PERM l1 l2' ⇒ (FIND (λx. FST x = y) l1 = FIND (λx. FST x = y) l2'),
 ALL_DISTINCT (MAP FST l1), FST h ∉ set (MAP FST l1), l2 = M ++ h::N,
 PERM (MAP FST l1) (MAP FST (M ++ N)), PERM l1 (M ++ N)]
|- FST h ∉ set (MAP FST M)

Number: 526
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀l1 l2 y.
     ALL_DISTINCT (MAP FST l1) ∧ PERM l1 l2 ⇒
     (FIND (λx. FST x = y) l1 = FIND (λx. FST x = y) l2)
 [] |- ∀l1 l2. PERM l1 l2 ⇔ PERM l2 l1
Goal:  [ALL_DISTINCT (MAP FST l2), PERM l1 l2]
|- (case FIND (λx. FST x = x') l1 of NONE => x x' | SOME (v1,e) => e) =
   case FIND (λx. FST x = x') l2 of NONE => x x' | SOME (v1,e) => e

Number: 529
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f r x y.
     RRESTRICT (f |+ (x,y)) r =
     if y ∈ r then RRESTRICT f r |+ (x,y)
     else RRESTRICT (DRESTRICT f (λa. a ≠ x)) r
 [] |- $IN = (λx f. f x)
Goal:  []
|- ∀f P x y.
     RRESTRICT (f |+ (x,y)) P =
     if P y then RRESTRICT f P |+ (x,y)
     else RRESTRICT (DRESTRICT f (λa. a ≠ x)) P

Number: 530
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f x y.
     FRANGE (f |+ (x,y)) = y INSERT FRANGE (DRESTRICT f (λa. a ≠ x))
 [] |- FRANGE FEMPTY = ∅
Goal:  []
|- (FRANGE FEMPTY = ∅) ∧
   ∀f x y.
     FRANGE (f |+ (x,y)) = y INSERT FRANGE (DRESTRICT f (λa. a ≠ x))

Number: 532
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀b x. BAG_VAL b x = b x
 [] |- ∀e b. BAG_INSERT e b = (λx. if x = e then b e + 1 else b x)
Goal:  [e ≠ x] |- BAG_INSERT e b x = b x

Number: 533
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀b x. BAG_VAL b x = b x
 [] |- ∀e b. BAG_INSERT e b = (λx. if x = e then b e + 1 else b x)
Goal:  [] |- BAG_INSERT e b e = b e + 1

Number: 534
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- ∀x. ¬(x ⋲ {||})
 [] |- ∀b e1 e2. e1 ⋲ BAG_INSERT e2 b ⇔ (e1 = e2) ∨ e1 ⋲ b
Goal:  [] |- (∀x. x ⋲ {||} ⇔ F) ∧ ∀x y. x ⋲ BAG_INSERT y b ⇔ (x = y) ∨ x ⋲ b

Number: 536
Status: Parsing failed
Info: polymorph bool num proof 
Thm list: 
 [] |- ∀x y s. x ∈ y INSERT s ⇔ (x = y) ∨ x ∈ s
Goal:  [x ∉ s]
|- (if x' ∈ x INSERT s then 1 else 0) =
   if x' = x then 1 else if x' ∈ s then 1 else 0

Number: 537
Status: Parsing failed
Info: polymorph num proof 
Thm list: 
 [] |- ∀x y s. x ∈ y INSERT s ⇔ (x = y) ∨ x ∈ s
Goal:  [x ∈ s] |- (if x' ∈ x INSERT s then 1 else 0) = if x' ∈ s then 1 else 0

Number: 538
Status: Time Out
Info: num proof 
Thm list: 
 [] |- ∀a b c. a + (b + c) = a + b + c
 [] |- ∀a b. a + b = b + a
 [] |- ∀m n. m * n = n * m
Goal: 
[∀x. SUC x = x + 1, ∀n. &n * &m = &(n * m),
 (n + 1) * (m + 1) = n * m + n + m + 1, &n * &SUC m = &(n * SUC m)]
|- &(n * m) + &n + &m + 1 = &m + &(m * n) + &n + 1

Number: 540
Status: Time Out
Info: proof 
Thm list: 
 []
|- ∀a b c d. b ≠ 0 ∧ d ≠ 0 ⇒ (a / b + c / d = (a * d + b * c) / (b * d))
 [] |- ∀x y. -(x * y) = -x * y
 [] |- ∀x y. -(x * y) = x * -y
Goal:  [b ≠ 0, d ≠ 0] |- a / b + -c / d = (a * d + -b * c) / (b * d)

Number: 554
Status: Unknown
Info: num proof 
Thm list: 
 [] |- ∀x y. x < y ⇒ x ≤ y
Goal:  [] |- (∀y. ∃n. y < &n) ⇒ ∃n. x ≤ &n

Number: 562
Status: Parsing failed
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀s.
     FINITE s ⇒
     (λs.
        ∀P f.
          (∀x. x ∈ s ⇒ P x) ⇒
          (REAL_SUM_IMAGE (λx. if P x then f x else 0) s =
           REAL_SUM_IMAGE f s)) s
Goal:  []
|- ∀s P f.
     FINITE s ∧ (∀x. x ∈ s ⇒ P x) ⇒
     (REAL_SUM_IMAGE (λx. if P x then f x else 0) s =
      REAL_SUM_IMAGE f s)

Number: 563
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- ∀x y s. x ∈ y INSERT s ⇔ (x = y) ∨ x ∈ s
Goal: 
[∀q. q ∈ e INSERT x INSERT t ⇒ (f x = f q), FINITE (x INSERT t),
 e ∉ x INSERT t, x ∉ t, p ∈ e INSERT x INSERT t]
|- x ∈ x INSERT t ∧ ∀q. q ∈ x INSERT t ⇒ (f x = f q)

Number: 565
Status: Time Out
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f c P.
     FINITE P ⇒
     (λP. REAL_SUM_IMAGE (λx. c * f x) P = c * REAL_SUM_IMAGE f P) P
Goal:  []
|- ∀P.
     FINITE P ⇒
     ∀f c. REAL_SUM_IMAGE (λx. c * f x) P = c * REAL_SUM_IMAGE f P

Number: 571
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀P.
     FINITE P ⇒
     ∀f.
       REAL_SUM_IMAGE f P =
       REAL_SUM_IMAGE (λx. if x ∈ P then f x else 0) P
Goal: 
[∀x. CARD (x INSERT s) = if x ∈ s then CARD s else CARD s + 1, FINITE s,
 s DELETE e = s]
|- REAL_SUM_IMAGE (λx. if (x = e) ∨ x ∈ s then 1 else 0) s =
   REAL_SUM_IMAGE
     (λx. if x ∈ s then (λx. if (x = e) ∨ x ∈ s then 1 else 0) x else 0)
     s

Number: 576
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[T, ∀x y. ((x = e) ∨ x ∈ s) ∧ ((y = e) ∨ y ∈ s) ⇒ (f x = f y),
 ∀f.
   (REAL_SUM_IMAGE f s = 1) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ (f x = f y)) ⇒
   ∀x. x ∈ s ⇒ (f x = inv (&CARD s)), FINITE s, e ∉ s]
|- (λx. if x ∈ s then f x else 0) =
   (λx. if x ∈ s then (λx. f e) x else 0)

Number: 578
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀x y. ((x = e) ∨ x ∈ s) ∧ ((y = e) ∨ y ∈ s) ⇒ (f x = f y),
 ∀f.
   (REAL_SUM_IMAGE f s = 1) ∧ (∀x y. x ∈ s ∧ y ∈ s ⇒ (f x = f y)) ⇒
   ∀x. x ∈ s ⇒ (f x = inv (&CARD s)), FINITE s, e ∉ s, x ∈ s]
|- (λx. if x ∈ s then f x else 0) =
   (λx. if x ∈ s then (λx. f e) x else 0)

Number: 584
Status: Unknown
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[∀x. (x = e) ∨ x ∈ s ⇒ (λn. f n x) --> f' x,
 ∀f f'.
   (∀x. x ∈ s ⇒ (λn. f n x) --> f' x) ⇒
   (λn. REAL_SUM_IMAGE (f n) s) --> REAL_SUM_IMAGE f' s, FINITE s,
 s DELETE e = s]
|- (λn. f n e) --> f' e ∧
   (λn. REAL_SUM_IMAGE (f n) s) --> REAL_SUM_IMAGE f' s

Number: 586
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- ∀x. (FST x,SND x) = x
 [] |- ((x,y) = (a,b)) ⇔ (x = a) ∧ (y = b)
Goal: 
[FINITE s, FINITE s', FINITE (s × s'), FST x = FST x', SND x = SND x',
 x ∈ s × s', x' ∈ s × s'] |- x = x'

Number: 591
Status: Parsing failed
Info: polymorph proof 
Thm list: 
 [] |- ∀x y. FST (x,y) = x
 [] |- ∀x y. SND (x,y) = y
 [] |- ∀x. (FST x,SND x) = x
Goal:  [FINITE s1, FINITE s2]
|- FST x ∈ s2 ∧ SND x ∈ s1 ⇔
   ∃a. (x = (SND a,FST a)) ∧ FST a ∈ s1 ∧ SND a ∈ s2

Number: 595
Status: Time Out
Info: proof 
Thm list: 
 []
|- ∀z w u v. w ≠ 0 ∧ v ≠ 0 ⇒ (z / w + u / v = (z * v + w * u) / (w * v))
 [] |- ∀z w. -(z * w) = -z * w
 [] |- ∀z w. -(z * w) = z * -w
Goal:  [v ≠ 0, w ≠ 0] |- z / w + -u / v = (z * v + -(w * u)) / (w * v)

Number: 598
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal:  [∃x. f x ≠ g x] |- (f = g) ∨ f (@i. f i ≠ g i) ≠ g (@i. f i ≠ g i)

Number: 599
Status: Time Out
Info: polymorph higher-order num proof 
Thm list: 
 [] |- ∀s t x. x ∈ s ∩ t ⇔ x ∈ s ∧ x ∈ t
 [] |- ∀P x. x ∈ P ⇔ P x
 [] |- ∀f s y. y ∈ BIGUNION (IMAGE f s) ⇔ ∃x. x ∈ s ∧ y ∈ f x
 [] |- ∀x. x ∈ 𝕌(:α)
Goal:  [] |- (f x ∩ BIGUNION (IMAGE f 𝕌(:num))) x' ⇔ f x x'

Number: 600
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m g x.
     algebra (m_space m,measurable_sets m) ∧ positive m ∧
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x
Goal:  [algebra (m_space m,measurable_sets m), positive m, g ⊆ m_space m]
|- ∀x.
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x

Number: 601
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m g x.
     algebra (m_space m,measurable_sets m) ∧ positive m ∧
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x
Goal: 
[algebra (m_space m,measurable_sets m), countably_additive m,
 positive m, s ∈ measurable_sets m]
|- ∀x.
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x

Number: 602
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m g x.
     algebra (m_space m,measurable_sets m) ∧ positive m ∧
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x
 [] |- ∀s. ∅ ⊆ s
Goal:  [algebra (m_space m,measurable_sets m), positive m]
|- ∃z.
     ∀x.
       x ∈
       {r |
        ∃f.
          f ∈ (𝕌(:num) -> measurable_sets m) ∧
          (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
          ∅ ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
       z ≤ x

Number: 603
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m g x.
     algebra (m_space m,measurable_sets m) ∧ positive m ∧
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x
Goal: 
[algebra (m_space m,measurable_sets m), positive m,
 x ∈
 {r |
  ∃f.
    f ∈ (𝕌(:num) -> measurable_sets m) ∧
    (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
    t ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r}, s ⊆ t,
 s ⊆ m_space m, t ⊆ m_space m]
|- ∀x.
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x

Number: 604
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m g x.
     algebra (m_space m,measurable_sets m) ∧ positive m ∧
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x
Goal: 
[∀x. f x ∈ measurable_sets m, algebra (m_space m,measurable_sets m),
 increasing m, positive m, summable (measure m o f),
 s ⊆ BIGUNION (IMAGE f 𝕌(:num))]
|- ∀x.
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x

Number: 605
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m g x.
     algebra (m_space m,measurable_sets m) ∧ positive m ∧
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        g ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x
Goal: 
[∀x. x ∈ s ⇒ x ∈ m_space m, ∀m n. m ≠ n ⇒ DISJOINT (f m) (f n),
 ∀x. f x ∈ measurable_sets m, additive m,
 algebra (m_space m,measurable_sets m), increasing m, positive m,
 summable (measure m o f), summable (measure m o (λs. x' ∩ s) o f),
 x ∈ measurable_sets m, x' ∈ measurable_sets m,
 s ⊆ BIGUNION (IMAGE f 𝕌(:num)), s ⊆ m_space m, 0 < e]
|- ∀x.
     x ∈
     {r |
      ∃f.
        f ∈ (𝕌(:num) -> measurable_sets m) ∧
        (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
        x' ∩ s ⊆ BIGUNION (IMAGE f 𝕌(:num)) ∧ measure m o f sums r} ⇒
     0 ≤ x

Number: 609
Status: Parsing failed
Info: polymorph higher-order proof 
Thm list: 
 [] |- ∀f P Q. f ∈ (P -> Q) ⇔ ∀x. x ∈ P ⇒ f x ∈ Q
Goal: 
[∀x. x ∈ s' ⇒ x ∈ sp, ∀s. s ∈ b ⇒ PREIMAGE f s ∩ space a ∈ subsets a,
 sigma_algebra a,
 (PREIMAGE f sp DIFF PREIMAGE f s') ∩ space a =
 PREIMAGE f sp ∩ space a DIFF PREIMAGE f s' ∩ space a,
 f ∈ (space a -> sp), PREIMAGE f s' ∩ space a ∈ subsets a,
 s ∈ subsets (sigma sp b), s' ∈ subsets (sigma sp b), subset_class sp b]
|- f x ∈ sp ∧ x ∈ space a ⇔ x ∈ space a

Number: 622
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal:  []
|- (∀s.
      FINITE s ⇒
      (λs.
         ∀m.
           measure_space m ∧ s ∈ measurable_sets m ∧
           (∀x. x ∈ s ⇒ {x} ∈ measurable_sets m) ⇒
           (measure m s = SIGMA (λx. measure m {x}) s)) s) ⇒
   ∀m s.
     measure_space m ∧ s ∈ measurable_sets m ∧
     (∀x. x ∈ s ⇒ {x} ∈ measurable_sets m) ∧ FINITE s ⇒
     (measure m s = SIGMA (λx. measure m {x}) s)

Number: 629
Status: Unknown
Info: polymorph higher-order num proof 
Thm list: 
 []
|- ∀f s.
     FINITE s ∧ (∀x. f x ∈ s) ∧ (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ⇒
     ∃N. ∀n. n ≥ N ⇒ (f n = ∅)
Goal: 
[∀s' t.
   s' ∈ subsets s ∧ t ∈ subsets s ∧ DISJOINT s' t ⇒
   (m (s' ∪ t) = m s' + m t), ∀m n. m ≠ n ⇒ DISJOINT (f m) (f n),
 ∀x. f x ∈ subsets s, FINITE (space s), FINITE (subsets s),
 positive (space s,subsets s,m), sigma_algebra s,
 BIGUNION (IMAGE f 𝕌(:num)) ∈ subsets s] |- ∃N. ∀n. n ≥ N ⇒ (f n = ∅)

Number: 644
Status: Unknown
Info: polymorph higher-order num proof 
Thm list: 
 []
|- ∀m.
     measure_space m ⇔
     sigma_algebra (m_space m,measurable_sets m) ∧ positive m ∧
     countably_additive m
Goal:  [∀n. s n ∈ measurable_sets m, measure_space m]
|- (sigma_algebra (m_space m,measurable_sets m) ⇒
    subset_class (m_space m) (measurable_sets m) ∧
    ∅ ∈ measurable_sets m ∧
    (∀s. s ∈ measurable_sets m ⇒ m_space m DIFF s ∈ measurable_sets m) ∧
    ∀f.
      (∀x. f x ∈ measurable_sets m) ⇒
      BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m) ⇒
   BIGINTER (IMAGE s 𝕌(:num)) ∈ measurable_sets m

Number: 646
Status: Unknown
Info: polymorph higher-order num proof 
Thm list: 
 []
|- ∀m s.
     measure_space m ∧ (∀n. s n ∈ measurable_sets m) ⇒
     BIGINTER (IMAGE s 𝕌(:num)) ∈ measurable_sets m
Goal:  [∀x. f x ∈ measurable_sets m, ∀n. f (SUC n) ⊆ f n, measure_space m]
|- BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m

Number: 648
Status: Parsing failed
Info: polymorph higher-order num proof 
Thm list: 
 [] |- ∀s f. (IMAGE f s = ∅) ⇔ (s = ∅)
 [] |- 𝕌(:α) ≠ ∅
 [] |- ∀y s f. y ∈ IMAGE f s ⇔ ∃x. (y = f x) ∧ x ∈ s
 [] |- ∀x. x ∈ 𝕌(:α)
Goal: 
[∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 measure_space m, BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m]
|- (∀t. t ∈ IMAGE f 𝕌(:num) ⇒ t ⊆ f 0) ∧ IMAGE f 𝕌(:num) ≠ ∅

Number: 649
Status: Unknown
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m s.
     measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ∧
     t ⊆ s ⇒
     (measure m (s DIFF t) = measure m s − measure m t)
Goal: 
[∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0]
|- ∀n. measure m (f 0) − measure m (f n) = measure m (g n)

Number: 650
Status: Time Out
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀x y z. (x = y − z) ⇔ (x + z = y)
 [] |- ∀x y z. (x − y = z) ⇔ (x = z + y)
 [] |- ∀x y. x − y = x + -y
 [] |- ∀x y. x + y = y + x
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0]
|- measure m (f x) = measure m (f 0) − measure m (g x)

Number: 651
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀y s f. y ∈ IMAGE f s ⇔ ∃x. (y = f x) ∧ x ∈ s
 [] |- ∀x. x ∈ 𝕌(:α)
 [] |- ∀s f. (IMAGE f s = ∅) ⇔ (s = ∅)
 [] |- 𝕌(:α) ≠ ∅
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0]
|- (∀t. t ∈ IMAGE f 𝕌(:num) ⇒ t ⊆ f 0) ∧ IMAGE f 𝕌(:num) ≠ ∅

Number: 652
Status: Time Out
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀s t. s ⊆ t ⇔ ∀x. x ∈ s ⇒ x ∈ t
 [] |- ∀s t x. x ∈ s DIFF t ⇔ x ∈ s ∧ x ∉ t
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0]
|- (∃u. (∃x. ∀x'. x' ∈ u ⇔ x' ∈ f x) ∧ x ∈ f 0 DIFF u) ⇔
   ∃n. x ∈ f 0 DIFF f n

Number: 653
Status: Unknown
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m s t.
     measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ⇒
     s DIFF t ∈ measurable_sets m
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0] |- g x ∈ measurable_sets m

Number: 655
Status: Unknown
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀k. (λx. k) --> k
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 (λn. measure m (g n)) --> measure m (BIGUNION (IMAGE g 𝕌(:num))),
 measure m (f 0 DIFF BIGUNION (IMAGE g 𝕌(:num))) =
 measure m (f 0) − measure m (BIGUNION (IMAGE g 𝕌(:num))),
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0]
|- (λx. measure m (f 0)) --> measure m (f 0) ∧
   (λx. measure m (g x)) --> measure m (BIGUNION (IMAGE g 𝕌(:num)))

Number: 656
Status: Unknown
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀m s t.
     measure_space m ∧ s ∈ measurable_sets m ∧ t ∈ measurable_sets m ⇒
     s DIFF t ∈ measurable_sets m
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 (λn. measure m (g n)) --> measure m (BIGUNION (IMAGE g 𝕌(:num))),
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0]
|- measure_space m ∧ ∀n. g n ∈ measurable_sets m

Number: 657
Status: Unknown
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀s t. s DIFF t ⊆ s
Goal: 
[∀n. measure m (f 0) − measure m (f n) = measure m (g n),
 ∀x. f x ∈ measurable_sets m, ∀n. f n ⊆ f 0, ∀n. f (SUC n) ⊆ f n,
 Abbrev (g = (λn. f 0 DIFF f n)), measure_space m,
 (λn. measure m (g n)) --> measure m (BIGUNION (IMAGE g 𝕌(:num))),
 BIGINTER (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 BIGINTER (IMAGE f 𝕌(:num)) ⊆ f 0] |- g x ⊆ f 0

Number: 670
Status: Unknown
Info: polymorph higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x x0 c. x sums x0 ⇒ (λn. c * x n) sums (c * x0)
 []
|- ∀m.
     countably_additive m ⇔
     ∀f.
       f ∈ (𝕌(:num) -> measurable_sets m) ∧
       (∀m n. m ≠ n ⇒ DISJOINT (f m) (f n)) ∧
       BIGUNION (IMAGE f 𝕌(:num)) ∈ measurable_sets m ⇒
       measure m o f sums measure m (BIGUNION (IMAGE f 𝕌(:num)))
Goal: 
[∀s. s ∈ measurable_sets m ⇒ 0 ≤ measure m s,
 ∀m n. m ≠ n ⇒ DISJOINT (f m) (f n), countably_additive m,
 sigma_algebra (m_space m,measurable_sets m), measure m ∅ = 0,
 BIGUNION (IMAGE f 𝕌(:num)) ∈ measurable_sets m,
 f ∈ (𝕌(:num) -> measurable_sets m), 0 ≤ c]
|- (λx. c * measure m (f x)) sums
   (c * measure m (BIGUNION (IMAGE f 𝕌(:num))))

Number: 672
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal:  [sigma_algebra a, sigma_algebra Borel, space Borel = 𝕌(:extreal)]
|- ∃a. {x | x < c} = {x | x < a}

Number: 673
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. PREIMAGE f {x | x < c} ∩ space a ∈ subsets a, sigma_algebra a,
 sigma_algebra Borel, space Borel = 𝕌(:extreal),
 f ∈ (space a -> 𝕌(:extreal))]
|- PREIMAGE f {x | x < a'} ∩ space a ∈ subsets a

Number: 674
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n. &n ≠ NegInf ∧ &n ≠ PosInf
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
 []
|- (-NegInf = PosInf) ∧ (-PosInf = NegInf) ∧ ∀x. -Normal x = Normal (-x)
 [] |- ∀n. &n = Normal (&n)
Goal:  [∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a]
|- (f x = NegInf) ∧ x ∈ space a ⇒ ∀n. f x < -&n ∧ x ∈ space a

Number: 675
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x. x ≠ PosInf ⇒ ∃n. x ≤ &n
 [] |- ∀x y. x < y ⇔ ¬(y ≤ x)
 []
|- (-NegInf = PosInf) ∧ (-PosInf = NegInf) ∧ ∀x. -Normal x = Normal (-x)
 [] |- ∀x. --x = x
 [] |- ∀x y. -x < -y ⇔ y < x
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a, ∀n. f x < -&n ∧ x ∈ space a,
 sigma_algebra a, f x ≠ NegInf] |- F

Number: 676
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
Goal: 
[∀c. {x | f x < c} = PREIMAGE f {x | x < c},
 ∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c ≤ f x} = PREIMAGE f {x | c ≤ x}]
|- ∀c. space a DIFF PREIMAGE f {x | x < c} ∩ space a ∈ subsets a

Number: 677
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀s t. s DIFF t ∩ s = s DIFF t
Goal: 
[∀c. {x | f x < c} = PREIMAGE f {x | x < c},
 ∀c. space a DIFF PREIMAGE f {x | x < c} ∩ space a ∈ subsets a,
 ∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c ≤ f x} = PREIMAGE f {x | c ≤ x}]
|- ∀c. space a DIFF PREIMAGE f {x | x < c} ∈ subsets a

Number: 678
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀f t sp. sp DIFF PREIMAGE f t = PREIMAGE f (COMPL t) ∩ sp
Goal: 
[∀c. {x | f x < c} = PREIMAGE f {x | x < c},
 ∀c. space a DIFF PREIMAGE f {x | x < c} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | x < c} ∈ subsets a,
 ∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c ≤ f x} = PREIMAGE f {x | c ≤ x}]
|- ∀c. PREIMAGE f (COMPL {x | x < c}) ∩ space a ∈ subsets a

Number: 679
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
Goal: 
[∀c. {x | c ≤ f x} = PREIMAGE f {x | c ≤ x},
 ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x < c} = PREIMAGE f {x | x < c}]
|- ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∩ space a ∈ subsets a

Number: 680
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀s t. s DIFF t ∩ s = s DIFF t
Goal: 
[∀c. {x | c ≤ f x} = PREIMAGE f {x | c ≤ x},
 ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∩ space a ∈ subsets a,
 ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x < c} = PREIMAGE f {x | x < c}]
|- ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∈ subsets a

Number: 681
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀f t sp. sp DIFF PREIMAGE f t = PREIMAGE f (COMPL t) ∩ sp
Goal: 
[∀c. {x | c ≤ f x} = PREIMAGE f {x | c ≤ x},
 ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∈ subsets a,
 ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x < c} = PREIMAGE f {x | x < c}]
|- ∀c. PREIMAGE f (COMPL {x | c ≤ x}) ∩ space a ∈ subsets a

Number: 682
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. {x | c ≤ f x} = PREIMAGE f {x | c ≤ x},
 ∀c. COMPL {x | c ≤ x} = {x | x < c},
 ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | c ≤ x} ∈ subsets a,
 ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a,
 ∀c. PREIMAGE f (COMPL {x | c ≤ x}) ∩ space a ∈ subsets a,
 sigma_algebra a, {x | f x < c} = PREIMAGE f {x | x < c}]
|- {x | f x < c} ∩ space a ∈ subsets a

Number: 683
Status: Time Out
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
 []
|- ∀f a.
     f ∈ measurable a Borel ⇒ {x | f x = NegInf} ∩ space a ∈ subsets a
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a,
 f ∈ (space a -> 𝕌(:extreal))]
|- {x | f x = NegInf} ∩ space a ∈ subsets a

Number: 685
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n. &n = Normal (&n)
 [] |- ∀x y. Normal x < Normal y ⇔ x < y
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a, x ∈ space a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal r, 0 < (1 / 2) pow n]
|- 0 < Normal ((1 / 2) pow n)

Number: 686
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
 []
|- (Normal x + Normal y = Normal (x + y)) ∧ (PosInf + a = PosInf) ∧
   (NegInf + PosInf = PosInf) ∧ (Normal v2 + PosInf = PosInf) ∧
   (NegInf + NegInf = NegInf) ∧ (NegInf + Normal v5 = NegInf) ∧
   (Normal v3 + NegInf = NegInf)
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a, f x = NegInf,
 x ∈ space a, f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal r,
 0 < Normal ((1 / 2) pow n), 0 < (1 / 2) pow n]
|- f x < Normal r + Normal ((1 / 2) pow n)

Number: 687
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀w x y z. w ≠ NegInf ∧ w ≠ PosInf ∧ w ≤ x ∧ y < z ⇒ w + y < x + z
 [] |- ∀n. &n = Normal (&n)
 [] |- ∀x. Normal x ≠ NegInf ∧ Normal x ≠ PosInf
 [] |- ∀x. x + 0 = x
 []
|- (∀x. NegInf ≤ x ∧ x ≤ PosInf) ∧ (∀x. x ≤ NegInf ⇔ (x = NegInf)) ∧
   ∀x. PosInf ≤ x ⇔ (x = PosInf)
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a, sigma_algebra a, f x ≠ NegInf,
 x ∈ space a, f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal r,
 0 < Normal ((1 / 2) pow n), 0 < (1 / 2) pow n]
|- f x < Normal r + Normal ((1 / 2) pow n)

Number: 688
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a,
 ∀n. f x < Normal (r + (1 / 2) pow n) ∧ x ∈ space a, sigma_algebra a,
 f ∈ (space a -> 𝕌(:extreal))] |- ∀n. f x < Normal (r + (1 / 2) pow n)

Number: 689
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- (λn. r) --> r ∧ (λn. (1 / 2) pow n) --> 0 ⇒
   (λn. (λn. r) n + (λn. (1 / 2) pow n) n) --> (r + 0)
 [] |- ∀x. x + 0 = x
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a,
 ∀n. f x < Normal (r + (1 / 2) pow n) ∧ x ∈ space a,
 ∀n. f x < Normal (r + (1 / 2) pow n), sigma_algebra a, (λn. r) --> r,
 (λn. (1 / 2) pow n) --> 0,
 (λn. r + (1 / 2) pow n) = (λn. (λn. r) n + (λn. (1 / 2) pow n) n),
 f ∈ (space a -> 𝕌(:extreal))] |- (λn. r + (1 / 2) pow n) --> r

Number: 690
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- (∀x. NegInf ≤ x ∧ x ≤ PosInf) ∧ (∀x. x ≤ NegInf ⇔ (x = NegInf)) ∧
   ∀x. PosInf ≤ x ⇔ (x = PosInf)
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a,
 ∀n. f x < Normal (r + (1 / 2) pow n) ∧ x ∈ space a,
 ∀n. f x < Normal (r + (1 / 2) pow n), sigma_algebra a, (λn. r) --> r,
 (λn. (1 / 2) pow n) --> 0, (λn. r + (1 / 2) pow n) --> r, f x = NegInf,
 (λn. r + (1 / 2) pow n) = (λn. (λn. r) n + (λn. (1 / 2) pow n) n),
 f ∈ (space a -> 𝕌(:extreal))] |- f x ≤ Normal r

Number: 691
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a,
 ∀n. f x < Normal (r + (1 / 2) pow n) ∧ x ∈ space a,
 ∀n. f x < Normal (r + (1 / 2) pow n), sigma_algebra a, f x ≠ NegInf,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r + (1 / 2) pow n) --> r,
 (λn. r + (1 / 2) pow n) = (λn. (λn. r) n + (λn. (1 / 2) pow n) n),
 f ∈ (space a -> 𝕌(:extreal))] |- f x ≠ PosInf

Number: 692
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x. (x = NegInf) ∨ (x = PosInf) ∨ ∃r. x = Normal r
Goal: 
[∀c. {x | f x < c} ∩ space a ∈ subsets a,
 ∀n. f x < Normal (r + (1 / 2) pow n) ∧ x ∈ space a,
 ∀n. f x < Normal (r + (1 / 2) pow n), sigma_algebra a, f x ≠ NegInf,
 f x ≠ PosInf, (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r + (1 / 2) pow n) --> r,
 (λn. r + (1 / 2) pow n) = (λn. (λn. r) n + (λn. (1 / 2) pow n) n),
 f ∈ (space a -> 𝕌(:extreal))] |- ∃r. f x = Normal r

Number: 693
Status: Unknown
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x y. x < y ⇒ x ≤ y
 []
|- (∀n. r' ≤ (λn. r + (1 / 2) pow n) n) ∧
   (λn. r + (1 / 2) pow n) --> r ⇒
   r' ≤ r
Goal: 
[T, ∀c. {x | f x < c} ∩ space a ∈ subsets a, ∀n. r' < r + (1 / 2) pow n,
 sigma_algebra a, Normal r' ≠ NegInf, Normal r' ≠ PosInf, (λn. r) --> r,
 (λn. (1 / 2) pow n) --> 0, (λn. r + (1 / 2) pow n) --> r,
 f x = Normal r', x ∈ space a, f ∈ (space a -> 𝕌(:extreal))] |- r' ≤ r

Number: 696
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
 [] |- ∀x y. x < y ⇔ ¬(y ≤ x)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a, sigma_algebra a,
 f ∈ (space a -> 𝕌(:extreal))]
|- c < f x ∧ x ∈ space a ⇔ x ∈ space a ∧ (¬(f x ≤ c) ∨ x ∉ space a)

Number: 697
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c < f x} ∩ space a = space a DIFF {x | f x ≤ c} ∩ space a,
 f ∈ (space a -> 𝕌(:extreal))] |- {x | c < f x} ∩ space a ∈ subsets a

Number: 698
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀n. &n ≠ NegInf ∧ &n ≠ PosInf
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 f ∈ (space a -> 𝕌(:extreal))]
|- (f x = PosInf) ∧ x ∈ space a ⇒ ∀n. &n < f x ∧ x ∈ space a

Number: 699
Status: Parsing failed
Info: higher-order lambda-lift num proof 
Thm list: 
 [] |- ∀x. x ≠ PosInf ⇒ ∃n. x ≤ &n
 [] |- ∀x y. x < y ⇔ ¬(y ≤ x)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, ∀n. &n < f x ∧ x ∈ space a,
 sigma_algebra a, f x ≠ PosInf, f ∈ (space a -> 𝕌(:extreal))] |- F

Number: 701
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 {x | f x = PosInf} ∩ space a ∈ subsets a, f ∈ (space a -> 𝕌(:extreal))]
|- space a DIFF
   BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)) ∈ subsets a

Number: 703
Status: Unknown
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- (λn. r) --> r ∧ (λn. (1 / 2) pow n) --> 0 ⇒
   (λn. (λn. r) n − (λn. (1 / 2) pow n) n) --> (r − 0)
 [] |- ∀x. x − 0 = x
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 {x | f x = PosInf} ∩ space a ∈ subsets a, f ∈ (space a -> 𝕌(:extreal))]
|- (λn. r − (1 / 2) pow n) --> r

Number: 704
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- (∀x. NegInf ≤ x ∧ x ≤ PosInf) ∧ (∀x. x ≤ NegInf ⇔ (x = NegInf)) ∧
   ∀x. PosInf ≤ x ⇔ (x = PosInf)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r, f x = NegInf,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x < Normal r]
|- ∃n. f x ≤ Normal (r − (1 / 2) pow n)

Number: 705
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a, f x ≠ NegInf,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x < Normal r] |- f x ≠ PosInf

Number: 706
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀x. (x = NegInf) ∨ (x = PosInf) ∨ ∃r. x = Normal r
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a, f x ≠ NegInf,
 f x ≠ PosInf, (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x < Normal r] |- ∃r. f x = Normal r

Number: 707
Status: Unknown
Info: higher-order lambda-lift bool num proof 
Thm list: 
Goal: 
[T, ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a,
 ∀n. abs ((1 / 2) pow n) = (1 / 2) pow n,
 ∀e. 0 < e ⇒ ∃N. ∀n. n ≥ N ⇒ abs ((1 / 2) pow n) < e, sigma_algebra a,
 Normal r' ≠ NegInf, Normal r' ≠ PosInf, (λn. r) --> r,
 (λn. (1 / 2) pow n) --> 0, (λn. r − (1 / 2) pow n) --> r,
 f x = Normal r',
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)), x ∈ space a,
 {x | f x = PosInf} ∩ space a ∈ subsets a, f ∈ (space a -> 𝕌(:extreal)),
 r' < r] |- ∀e. 0 < e ⇒ ∃N. ∀n. n ≥ N ⇒ (1 / 2) pow n < e

Number: 708
Status: Time Out
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀x y. 0 < x − y ⇔ y < x
Goal: 
[T, ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a,
 ∀n. abs ((1 / 2) pow n) = (1 / 2) pow n,
 ∀e. 0 < e ⇒ ∃N. ∀n. n ≥ N ⇒ abs ((1 / 2) pow n) < e,
 ∀e. 0 < e ⇒ ∃N. ∀n. n ≥ N ⇒ (1 / 2) pow n < e, sigma_algebra a,
 Normal r' ≠ NegInf, Normal r' ≠ PosInf, (λn. r) --> r,
 (λn. (1 / 2) pow n) --> 0, (λn. r − (1 / 2) pow n) --> r,
 f x = Normal r',
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)), x ∈ space a,
 {x | f x = PosInf} ∩ space a ∈ subsets a, f ∈ (space a -> 𝕌(:extreal)),
 r' < r] |- ∃N. ∀n. n ≥ N ⇒ (1 / 2) pow n < r − r'

Number: 709
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀x n. 0 < x ⇒ 0 < x pow n
 [] |- -0 = 0
 [] |- ∀x y. -x < -y ⇔ y < x
 [] |- 0 < 1 / 2 ⇔ T
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal (r − (1 / 2) pow n)]
|- ∀n. -((1 / 2) pow n) < 0

Number: 710
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀x y z. y < z ⇒ x + y < x + z
 [] |- ∀x. x + 0 = x
 [] |- ∀x y. x − y = x + -y
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, ∀n. -((1 / 2) pow n) < 0,
 sigma_algebra a, (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal (r − (1 / 2) pow n)]
|- ∀n. r − (1 / 2) pow n < r

Number: 711
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- ∀x y.
     NegInf < Normal y ∧ Normal y < PosInf ∧ NegInf < PosInf ∧
     ¬(x < NegInf) ∧ ¬(PosInf < x) ∧ (x ≠ PosInf ⇔ x < PosInf) ∧
     (x ≠ NegInf ⇔ NegInf < x)
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, ∀n. -((1 / 2) pow n) < 0,
 ∀n. r − (1 / 2) pow n < r, sigma_algebra a, (λn. r) --> r,
 (λn. (1 / 2) pow n) --> 0, (λn. r − (1 / 2) pow n) --> r, f x = NegInf,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal (r − (1 / 2) pow n)]
|- f x < Normal r

Number: 712
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 []
|- (∀x. NegInf ≤ x ∧ x ≤ PosInf) ∧ (∀x. x ≤ NegInf ⇔ (x = NegInf)) ∧
   ∀x. PosInf ≤ x ⇔ (x = PosInf)
 [] |- ∀x. Normal x ≠ NegInf ∧ Normal x ≠ PosInf
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, ∀n. -((1 / 2) pow n) < 0,
 ∀n. r − (1 / 2) pow n < r, sigma_algebra a, f x ≠ NegInf,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal (r − (1 / 2) pow n)]
|- f x ≠ PosInf

Number: 713
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
 [] |- ∀x. (x = NegInf) ∨ (x = PosInf) ∨ ∃r. x = Normal r
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, ∀n. -((1 / 2) pow n) < 0,
 ∀n. r − (1 / 2) pow n < r, sigma_algebra a, f x ≠ NegInf, f x ≠ PosInf,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal (r − (1 / 2) pow n)]
|- ∃r. f x = Normal r

Number: 715
Status: Parsing failed
Info: higher-order lambda-lift bool num proof 
Thm list: 
Goal: 
[∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 (λn. r) --> r, (λn. (1 / 2) pow n) --> 0,
 (λn. r − (1 / 2) pow n) --> r,
 {x | f x ≠ PosInf} ∩ space a =
 space a DIFF {x | f x = PosInf} ∩ space a,
 {x | f x = PosInf} ∩ space a =
 BIGINTER (IMAGE (λn. {x | &n < f x} ∩ space a) 𝕌(:num)),
 (λn. r − (1 / 2) pow n) = (λn. (λn. r) n − (λn. (1 / 2) pow n) n),
 x ∈ space a, {x | f x = PosInf} ∩ space a ∈ subsets a,
 f ∈ (space a -> 𝕌(:extreal)), f x ≤ Normal (r − (1 / 2) pow n)]
|- x ∈ space a

Number: 716
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
Goal: 
[∀c. {x | f x ≤ c} = PREIMAGE f {x | x ≤ c},
 ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c < f x} = PREIMAGE f {x | c < x}, f ∈ (space a -> 𝕌(:extreal))]
|- ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∩ space a ∈ subsets a

Number: 717
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀s t. s DIFF t ∩ s = s DIFF t
Goal: 
[∀c. {x | f x ≤ c} = PREIMAGE f {x | x ≤ c},
 ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∩ space a ∈ subsets a,
 ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c < f x} = PREIMAGE f {x | c < x}, f ∈ (space a -> 𝕌(:extreal))]
|- ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∈ subsets a

Number: 718
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀f t sp. sp DIFF PREIMAGE f t = PREIMAGE f (COMPL t) ∩ sp
Goal: 
[∀c. {x | f x ≤ c} = PREIMAGE f {x | x ≤ c},
 ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∈ subsets a,
 ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c < f x} = PREIMAGE f {x | c < x}, f ∈ (space a -> 𝕌(:extreal))]
|- ∀c. PREIMAGE f (COMPL {x | x ≤ c}) ∩ space a ∈ subsets a

Number: 719
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. {x | f x ≤ c} = PREIMAGE f {x | x ≤ c},
 ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | x ≤ c} ∈ subsets a,
 ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a,
 ∀c. PREIMAGE f (COMPL {x | x ≤ c}) ∩ space a ∈ subsets a,
 sigma_algebra a, {x | c < f x} = PREIMAGE f {x | c < x},
 COMPL {x | x ≤ c} = {x | c < x}, f ∈ (space a -> 𝕌(:extreal))]
|- {x | c < f x} ∩ space a ∈ subsets a

Number: 720
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
Goal: 
[∀c. {x | c < f x} = PREIMAGE f {x | c < x},
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x ≤ c} = PREIMAGE f {x | x ≤ c}, f ∈ (space a -> 𝕌(:extreal))]
|- ∀c. space a DIFF PREIMAGE f {x | c < x} ∩ space a ∈ subsets a

Number: 721
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀s t. s DIFF t ∩ s = s DIFF t
Goal: 
[∀c. {x | c < f x} = PREIMAGE f {x | c < x},
 ∀c. space a DIFF PREIMAGE f {x | c < x} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x ≤ c} = PREIMAGE f {x | x ≤ c}, f ∈ (space a -> 𝕌(:extreal))]
|- ∀c. space a DIFF PREIMAGE f {x | c < x} ∈ subsets a

Number: 722
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 [] |- ∀f t sp. sp DIFF PREIMAGE f t = PREIMAGE f (COMPL t) ∩ sp
Goal: 
[∀c. {x | c < f x} = PREIMAGE f {x | c < x},
 ∀c. space a DIFF PREIMAGE f {x | c < x} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | c < x} ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x ≤ c} = PREIMAGE f {x | x ≤ c}, f ∈ (space a -> 𝕌(:extreal))]
|- ∀c. PREIMAGE f (COMPL {x | c < x}) ∩ space a ∈ subsets a

Number: 723
Status: Satisfiable
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. {x | c < f x} = PREIMAGE f {x | c < x},
 ∀c. space a DIFF PREIMAGE f {x | c < x} ∩ space a ∈ subsets a,
 ∀c. space a DIFF PREIMAGE f {x | c < x} ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a,
 ∀c. PREIMAGE f (COMPL {x | c < x}) ∩ space a ∈ subsets a,
 sigma_algebra a, {x | f x ≤ c} = PREIMAGE f {x | x ≤ c},
 COMPL {x | c < x} = {x | x ≤ c}, f ∈ (space a -> 𝕌(:extreal))]
|- {x | f x ≤ c} ∩ space a ∈ subsets a

Number: 726
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
Goal:  [f ∈ measurable a Borel] |- ∀d. {x | f x < d} ∩ space a ∈ subsets a

Number: 727
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a
Goal:  [∀d. {x | f x < d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a

Number: 728
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. {x | c ≤ f x} ∩ space a ∈ subsets a,
 ∀d. {x | f x < d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- (c ≤ f x ∧ f x < d) ∧ x ∈ space a ⇔
   (c ≤ f x ∧ x ∈ space a) ∧ f x < d ∧ x ∈ space a

Number: 729
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀a s t. algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
Goal: 
[∀c. {x | c ≤ f x} ∩ space a ∈ subsets a,
 ∀d. {x | f x < d} ∩ space a ∈ subsets a,
 {x | c ≤ f x ∧ f x < d} ∩ space a =
 {x | c ≤ f x} ∩ space a ∩ ({x | f x < d} ∩ space a),
 f ∈ measurable a Borel]
|- {x | c ≤ f x ∧ f x < d} ∩ space a ∈ subsets a

Number: 730
Status: Parsing failed
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[∀c d. {x | c ≤ f x ∧ f x < d} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x < c} ∩ space a = {x | NegInf ≤ f x ∧ f x < c} ∩ space a,
 f ∈ (space a -> 𝕌(:extreal))] |- {x | f x < c} ∩ space a ∈ subsets a

Number: 733
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a
Goal:  [f ∈ measurable a Borel] |- ∀d. {x | f x ≤ d} ∩ space a ∈ subsets a

Number: 734
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | c < f x} ∩ space a ∈ subsets a
Goal:  [∀d. {x | f x ≤ d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- ∀c. {x | c < f x} ∩ space a ∈ subsets a

Number: 735
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀d. {x | f x ≤ d} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- (c < f x ∧ f x ≤ d) ∧ x ∈ space a ⇔
   (c < f x ∧ x ∈ space a) ∧ f x ≤ d ∧ x ∈ space a

Number: 736
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀a s t. algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
Goal: 
[∀d. {x | f x ≤ d} ∩ space a ∈ subsets a,
 ∀c. {x | c < f x} ∩ space a ∈ subsets a,
 {x | c < f x ∧ f x ≤ d} ∩ space a =
 {x | c < f x} ∩ space a ∩ ({x | f x ≤ d} ∩ space a),
 f ∈ measurable a Borel]
|- {x | c < f x ∧ f x ≤ d} ∩ space a ∈ subsets a

Number: 737
Status: Parsing failed
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[∀c d. {x | c < f x ∧ f x ≤ d} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | c < f x} ∩ space a = {x | c < f x ∧ f x ≤ PosInf} ∩ space a,
 f ∈ (space a -> 𝕌(:extreal))] |- {x | c < f x} ∩ space a ∈ subsets a

Number: 740
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x ≤ c} ∩ space a ∈ subsets a
Goal:  [f ∈ measurable a Borel] |- ∀d. {x | f x ≤ d} ∩ space a ∈ subsets a

Number: 741
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a
Goal:  [∀d. {x | f x ≤ d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- ∀c. {x | c ≤ f x} ∩ space a ∈ subsets a

Number: 742
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. {x | c ≤ f x} ∩ space a ∈ subsets a,
 ∀d. {x | f x ≤ d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- (c ≤ f x ∧ f x ≤ d) ∧ x ∈ space a ⇔
   (c ≤ f x ∧ x ∈ space a) ∧ f x ≤ d ∧ x ∈ space a

Number: 743
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀a s t. algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
Goal: 
[∀c. {x | c ≤ f x} ∩ space a ∈ subsets a,
 ∀d. {x | f x ≤ d} ∩ space a ∈ subsets a,
 {x | c ≤ f x ∧ f x ≤ d} ∩ space a =
 {x | c ≤ f x} ∩ space a ∩ ({x | f x ≤ d} ∩ space a),
 f ∈ measurable a Borel]
|- {x | c ≤ f x ∧ f x ≤ d} ∩ space a ∈ subsets a

Number: 744
Status: Parsing failed
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[∀c d. {x | c ≤ f x ∧ f x ≤ d} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x ≤ c} ∩ space a = {x | NegInf ≤ f x ∧ f x ≤ c} ∩ space a,
 f ∈ (space a -> 𝕌(:extreal))] |- {x | f x ≤ c} ∩ space a ∈ subsets a

Number: 745
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
Goal:  [f ∈ measurable a Borel] |- ∀d. {x | f x < d} ∩ space a ∈ subsets a

Number: 746
Status: Satisfiable
Info: polymorph higher-order lambda-lift proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | c < f x} ∩ space a ∈ subsets a
Goal:  [∀d. {x | f x < d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- ∀c. {x | c < f x} ∩ space a ∈ subsets a

Number: 747
Status: Parsing failed
Info: higher-order lambda-lift proof 
Thm list: 
Goal: 
[∀c. {x | c < f x} ∩ space a ∈ subsets a,
 ∀d. {x | f x < d} ∩ space a ∈ subsets a, f ∈ measurable a Borel]
|- (c < f x ∧ f x < d) ∧ x ∈ space a ⇔
   (c < f x ∧ x ∈ space a) ∧ f x < d ∧ x ∈ space a

Number: 748
Status: Parsing failed
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀a s t. algebra a ∧ s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∩ t ∈ subsets a
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
Goal: 
[∀c. {x | c < f x} ∩ space a ∈ subsets a,
 ∀d. {x | f x < d} ∩ space a ∈ subsets a,
 {x | c < f x ∧ f x < d} ∩ space a =
 {x | c < f x} ∩ space a ∩ ({x | f x < d} ∩ space a),
 f ∈ measurable a Borel]
|- {x | c < f x ∧ f x < d} ∩ space a ∈ subsets a

Number: 751
Status: Time Out
Info: higher-order lambda-lift bool proof 
Thm list: 
Goal: 
[∀c d. {x | c ≤ f x ∧ f x ≤ d} ∩ space a ∈ subsets a, sigma_algebra a,
 {x | f x = c} = {x | c ≤ f x ∧ f x ≤ c}, f ∈ (space a -> 𝕌(:extreal))]
|- {x | f x = c} ∩ space a ∈ subsets a

Number: 753
Status: Time Out
Info: polymorph higher-order lambda-lift bool proof 
Thm list: 
 []
|- ∀f a.
     f ∈ measurable a Borel ⇔
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x < c} ∩ space a ∈ subsets a
 []
|- ∀f a.
     f ∈ measurable a Borel ⇒
     sigma_algebra a ∧ f ∈ (space a -> 𝕌(:extreal)) ∧
     ∀c. {x | f x = c} ∩ space a ∈ subsets a
 []
|- ∀a.
     sigma_algebra a ⇔
     algebra a ∧
     ∀c. countable c ∧ c ⊆ subsets a ⇒ BIGUNION c ∈ subsets a
 []
|- ∀a.
     algebra a ⇔
     subset_class (space a) (subsets a) ∧ ∅ ∈ subsets a ∧
     (∀s. s ∈ subsets a ⇒ space a DIFF s ∈ subsets a) ∧
     ∀s t. s ∈ subsets a ∧ t ∈ subsets a ⇒ s ∪ t ∈ subsets a
Goal: 
[{x | f x ≠ c} ∩ space a = space a DIFF {x | f x = c} ∩ space a,
 f ∈ measurable a Borel] |- {x | f x ≠ c} ∩ space a ∈ subsets a

