
Axioms:
  used as def
  or used as axioms
  build it form the user input

 
Monomorph: 
  instantiate types (monomorphism)
    free variables are instantiate so that they match
  
Replacedef:  
  replace some of the constant into the formula
    figure out an heuristic
  replace some free variables by their definition
    in the formula   

First order and normal form: 
  Should negate the goal and prove false 
  (goal is not considered specially any more)
 
  reducing to first order clauses
    beta-reduction
    extract all lonely abstraction 
      (name them make a dict for lonely abstraction
      be careful to use alpha conversion here or an equality that take care of alpha conversion)
      )
 
   extract boolean argument
    
    make a dict for every type used (use of arity is necessary)
    make a dict for free variables (name, and type name) 
   (includes appdictionnary)
    
    add  app operator app_1,app_2,app_3 if app_1 is already used, use app_1_0, app_1_1 , etc
    make a dict for app the string will exactly be the name
    
      
 getting rid of existential quantifier
    skolemisation (have a dictionnary for skolem constants)  

 make it to normal form conjonction of clauses
  
  
 transform it to list of clauses maybe (use mlibclause and mlibclauseSet)
 
  make a dict for bound variables (can be done because there is no more nested implication)
    print the list of clauses to tff (never went to an internal representation)
    
Main: 
   globally make important module function in a certain order 
    
    
    