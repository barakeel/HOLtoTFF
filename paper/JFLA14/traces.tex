\section{Vérification des preuves \tff}
\label{sec:traces}
%Les travaux présentés dans cette partie sont en cours de développement.

Jusqu'ici, le prouveur externe est utilisé par \holfour comme un
oracle: s'il résout le problème traduit, celui-ci est ajouté à \holfour
comme un axiome. Nous n'avons donc aucune garantie que son raisonnement,
et donc l'axiome ajouté, sont corrects.

Pour utiliser des prouveurs externes sans compromettre la correction de
\holfour, nous utilisons l'approche \emph{sceptique} consistant à
vérifier en \holfour les traces éventuellement générées par ces
prouveurs. Pour conserver la généricité, nous vérifions des traces
fournies dans le format \tff.

Outre offrir plus de garanties à \holfour, la vérification de traces
\tff peut être utilisés pour garantir les résultats donnés par des
prouveurs du premier ordre lors d'autres utilisations.


\subsection{Vérification des preuves}

\subsubsection{Le lecteur}
Le lecteur du vérificateur peut actuellement lire des preuves dont les étapes sont des clauses au format \tff dont la numération respecte la convention \tff pour les \textit{split}. Les dictionnaires de variables, constantes et types produit par l'impression du problème sont utilisés pour lire le fichier preuve au format \tff. En résumé, le lecteur accepte seulement des fichiers preuves, contenant seulement des clauses, dont le fichier problème a été créé par \holfour.

\subsubsection{Le rejouage de la preuve}
Les tactiques \metistac et \coopertac (une implémentation de l'algorithme de Cooper pour l'arithmétique de Presburger voir \cite{Norrish03completeinteger})
sont utilisés conjointement pour rejouer les étapes de la preuve. 
Les raisonnements par disjonction de cas (\textit{split}) sont pris en compte grâce à la numérotation des clauses.


\subsection{Preuve de correction}
\begin{thm}(Correction)
\\Une conjecture dont la preuve a été rejouée dans \holfour est un théorème.
\end{thm}

\begin{proof}(Idée de la preuve)
\\La preuve de ce théorème ce décompose en deux parties la preuve de la traduction et la preuve du rejouage.
\\La traduction est correcte. [voir preuve de correction]
\\Le rejouage est correcte: Chaque étape de la preuve est rejouée par \metistac ou \coopertac, il est nécessaire de montrer que \metistac est \coopertac sont correctes, ce qui a été fait dans les papiers suivants [ref].
\end{proof}



\subsection{Application à \beagle}

\subsubsection{Génération de traces par Beagle}
  Voici le fonctionnement global de beagle et l'endroit d'où sont tirés les clauses composant la trace. 

\begin{center}
\begin{tikzpicture}[auto]
  % Place nodes
  \node [cloud] (NCS) {nouvel ensemble};
  \node [cloud, fill=white, above of=NCS, node distance = 1.5cm] (init) {fichier TFF};
  \node [label = 2, cloud, below of=NCS, node distance = 2cm] (OCS) {ancien ensemble};
  % Draw edges
  \draw[-to,black,ultra thick] (NCS.east) to [out=0,in=0] node[name=down]{1} (OCS.east) ;
  \draw[-to,black,ultra thick] (OCS.west) to [out=180,in=180] node[name=up]{3} (NCS.west)  ;
  \draw[-to,black,ultra thick] (init) -- node[name=what]{parsing et normalisation} (NCS)  ;  
  % Place boxes
  \node [block, right of=down, node distance=1.5cm] (rightbox)  
  {Transfère une clause};  
  \node [block, below of=OCS, node distance=1.5cm] (downbox)  
  {Applique les règles possibles*};      
  \node [block, left of=up, node distance=1.5cm] (leftbox)  
  {Transfère les clauses créées}; 
  \node [cloud, fill=white, below of=rightbox, node distance=2.5cm] (trace){fichier trace};
  \draw [-to,black,ultra thick] (down.west) to [out=270,in=90] (trace)  ;  
\end{tikzpicture}
\end{center}
(* Si la règle est un $Split$ la boucle se sépare en deux boucles disjointes (voir Définition).)

Lors d'une preuve linéaire (ne contenant pas de $Split$), les clauses tranférées vers l'ancien ensemble de clause sont ajoutées au fichier trace dans l'ordre où elles ont été déduites avec la numérotation correspondante.

\begin{mydef} ($Split$)
Soit a saturation loop state by a triplet (c, OCS ,NCS) where c is the clause which was moved from NCS to OCS. 
A Split is defined by this inference step. 
\\Let $a_1 \vee a_2$ a clause.

\begin{prooftree}
\AxiomC{$(a_1 \vee a_2,OCS,NCS)$}
\RightLabel{$Split$}
\UnaryInfC{$(a_1,OCS,NCS),(a_2,OCS,NCS),\ldots,(a_N,OCS,NCS)$}  
\end{prooftree}  
\end{mydef}  

Voici la règle $Split$
Une règle permmettant de faire des raisonnement par disjonction de cas.
En pratique, cette règle est implémenté comme un raisonnement par l'absurde avec comme hypothèse la partie gauche de la disjonction. C'est 
Mémorisation des différents niveau de split par numérotation des différentes branches de l'arbre créés comme le montre cet exemple:

Exemple.

Le fait de sauvegarder l'ancien ensemble et non le nouveau ensemble permet de garder seulement les étapes importantes de la preuve et donc de gagner du temps lors du rejouage. Cependant, les étapes manquantes doivent être complétées. Par exemple, lorsque la clause F (faux) est déduite dans le nouvel ensemble à la fin d'un raisonnement par l'absurde, nous parvenons à le savoir car la numérotation nous indique que nous changeons de branche.  

\subsubsection{Description sur une expérience}
 Voici les étapes d'une expérience
 
 Fichier preuve:
 Représentation interne à HOL et rejouage étape par étape de la preuve.
 
 


