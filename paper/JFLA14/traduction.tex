\section{Une traduction prouvée de la logique d'ordre supérieur vers la
  logique du premier ordre}
\label{sec:traduction}
 
A mettre quelque part (Où trouver le code source?) (déjà mis dans l'intro)
\path{https://github.com/barakeel/HOLtoTFF}. Some examples can be found in paperexample.sml.

\subsection{Présentation}

\subsection{Ordre de la traduction et de l'impression}

\begin{itemize}    
  \item Monomorphisation: cette étape aurait pu \^etre effectuée à n'importe quel moment mais la faire en premier rend le programme plus efficace \cite{MengP08}.
  \item Négation de la conclusion (preuve par l'absurde)
  \item Mise sous forme normale conjonctive: pour réaliser cette étape, la fonction \textsf{CNF$\_$CONV} codé par Joe Hurd en Octobre 2001 a été utilisée.
  \item $\lambda$-lifting: L'élimination des abstractions a été faite de la m\^eme manière dans [ref] et par utilisation des combinateurs dans [ref]  . 
  \item Elimination des arguments booléens qui ne sont pas des variables:
  Le type booléen $\$o$ étant réservé au prédicats, on remplace les arguments de types booléens par des variables. Ces variables seront imprimées avec un nouveau type $bool$.
  [ref]   
  \item Mise sous forme d'un ensemble de clauses     
  \item Elimination de l'ordre supérieur: Cette étape convertit toutes les fonctions en arguments si le problème est de l'ordre supérieur. Nous avons choisi de la faire presque en dernier pour limiter le nombre de problème considérée comme étant de l'ordre supérieur ($\exists f.\ \forall x.\ f\ x = 0$ ne sera pas une formule d'ordre supérieur). De plus, si elle est effectuée, nous conservons les constantes arithmétiques comme des fonctions afin que \beagle puisse les reconna\^itre. Des descriptions plus précises de cette étape peuvent \^etre trouvées dans [ref]

  \item Instanciation des variables booléennes liées.
  
Cette étape a été ajoutée car \beagle boucle sur les formules du type $\forall x:bool,\ x = T \vee x = F$.
  \item Traduction des variables de type $num$(entier positif) en des variables de type $int$(entier). Traduction des fonctions prenant en arguments des numéraux en des fonctions prenant en argument des entiers
  
Cette étape est nécessaire car le format TFF n'a pas de type numeral.
\end{itemize}  


\begin{itemize}
    \item Impression
    \subitem Variables ou constantes.  
    \subitem Types.
    \subitem True and false constants.
    \subitem Non-linear integer arithmetic.
lien vers des papiers expliquant les étapes qui sont déjà dans la
  littérature
\end{itemize}  

\subsection{Preuve de correction}

\begin{thm}(Correction de la traduction)

Si le problème traduit est un théorème alors le problème dans sa forme original est un théorème.
\end{thm}

\begin{proof}(Idée de la preuve)

La traduction est correcte car chaque étape de la traduction est correcte [voir présentation de la traduction]. Cette affirmation est soutenue par l'expérience [voir expérience avec Beagle].
\end{proof}

\subsection{Nouveaux aspects}
\label{sec:traduction:nouveautes}

\subsubsection{Monomorphisation}
Cette étape consiste à instancier les théorèmes contenant des types polymorphiques par d'autres types. Cela est nécessaire car le format \tff n'a pas de types polymorphiques.
  
\begin{example}
Soit un problème consitué d'un théorème $!x:a.\ {\color{green}C}\ x\ x$ et d'un but ${\color{blue}C} \ 42\ 42$. Si nous intancions le théorème avec la substitution $[a \mapsto num]$, le but sera aisément prouvable.
Nous cherchons donc instancier le type de la constante ${\color{green}C} : a \rightarrow a \rightarrow bool$ de tel sorte qu'il soit égal au type de la constante du m\^eme nom ${\color{blue}C} : num \rightarrow num \rightarrow bool$ et d'appliquer la substitution sous-jacente au théorème.
\end{example}
 
\begin{remark}

\end{remark} 
  
Le raisonnement décrit dans l'exemple nous permet de limiter ainsi le nombre d'instanciation possible ainsi de diminuer la largeur du champ de recherche. Nous rappelons que cette étape est incomplète car entre autres finie.[ref]

\subsubsection{Graphe de dépendance}
Dans cette partie, nous présentons une représentation théorique de notre implémentation de la monomorphisation. 
\vspace{2mm}

\noindent Pour chaque problème un graphe de dépendance peut \^etre défini.
\begin{mydef} (Graphe de dépendance)
\begin{enumerate}
  \item [-] Les constantes présentes dans la liste de théorèmes et dans le but sont les noeuds du graphe. Deux m\^eme constantes sont representé par des noeuds différents si elles proviennent de deux propositions (théorèmes ou buts) différentes.
  \item [-] Les flèches de {\color{blue}substitution} relient deux constantes vérifiant: 
    \subitem La constante origine n'appartient pas au but. (Les types polymorphiques contenus dans le but ne sont pas instanciables.)
    \subitem Elles ont le m\^eme nom.
    \subitem Le type du destinataire est une instance du type de l'origine.
  \item [-] Les ar\^etes de {\color{green}partage} relient deux constantes vérifiant:
    \subitem Elles appartiennent à un m\^eme théorème.
    \subitem Elles partagent une m\^eme variable polymorphique.   
\end{enumerate}    
De chaque flèche de substitution, on peut inférer une substitution. Quand il n'y a pas d'ambiguité, nous identifierons la flèche et la substitution.
Lorsque nous représenterons un graphe de dépendance ou son supergraphe.  (voir plus tard), nous dessinerons les constantes de la m\^eme proposition sur la m\^eme ligne. Par convention, les types polymorphiques seront représentés par les lettres a,b,c,d.
\end{mydef}


\begin{mydef} (A substitution transformation)
The substitution transformation $\mathcal{T}_s$ of a dependency graph $G$ for a substitution link $\sigma$ from $c$ to $c'$, is defined by:
\[\mathcal{T}_s(G) = G \cup \sigma(c) \]
where the created image stays in the same theorem.
\end{mydef}

\iffalse
\noindent \textit{New dependency graph using the right substitution link as a substitution transformation.}

\begin{center}
\begin{tikzpicture}[node distance = 3cm, auto]
  \node [cloud, fill=white,node distance = 3cm] (c11) {C: a};
  \node [cloud, fill=white, right of=c11,node distance = 3cm] (c12) {D: a};
  \node [cloud, fill=white, right of=c12,node distance = 3cm] (c13) {D: num};
  \node [cloud, fill=white, below of=c11,node distance = 1.5cm] (c21) {C: b};
  \node [cloud, fill=white, below of=c12,node distance = 3cm] (c32) {D: num};
  \draw[-to,blue,ultra thick](c11) -- (c21);
  \draw [-to,blue,ultra thick] (c21) -- (c11);
  \draw [-to,blue,ultra thick] (c12) -- (c32);
  \draw [-to,blue,ultra thick] (c13) -- (c32);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
\end{center}
\fi

\begin{mydef} (A partage transformation)
The partage transformation $\mathcal{T}_b$ of a graph $G$, for a partage link from $c$ to $c'$ and a substitution link $\sigma$ from $c'$ to $c''$, is defined by:
\[\mathcal{T}_b(G) = G \cup \sigma(c) \]
où l'image créé est lié au m\^eme théorème que $c$.S
\end{mydef}

\iffalse
\begin{center}
\begin{tikzpicture}[node distance = 3cm, auto]
  \node [cloud, fill=white,node distance = 3cm] (c11) {C: a};
  \node [cloud, fill=white, right of=c11,node distance = 3cm] (c12) {D: a};
  \node [cloud, fill=white, right of=c12,node distance = 3cm] (c13) {C: num};
  \node [cloud, fill=white, below of=c11,node distance = 1.5cm] (c21) {C: b};
  \node [cloud, fill=white, below of=c12,node distance = 3cm] (c32) {D: num};
  \draw[-to,blue,ultra thick](c11) -- (c21);
  \draw [-to,blue,ultra thick] (c21) -- (c11);
  \draw [-to,blue,ultra thick] (c12) -- (c32);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
\end{center}
\fi

\begin{mydef} (Une transformation d'un graphe)
La transformation $\mathcal{T}$ d'un graphe de dépendance $G$ est défini comme l'application de toutes les transformations de substitution et de partage possible à ce graphe de façon simultanée. Soit $G_O$ le graphe d'un problème, nous appellerons $G_1,G_2,\ldots,G_i$ les graphes créés après $1,2,\ldots,i$ itérations de $\mathcal{T}$.
\end{mydef}

\begin{figure}[h!]
\begin{tabularx}{\textwidth}{ X X }

\centering
\begin{tikzpicture}[node distance = 3cm, auto]
  \node [cloud, fill=white,node distance = 3cm] (c11) {C: a};
  \node [cloud, fill=white, right of=c11,node distance = 3cm] (c12) {D: a};
  \node [cloud, fill=white, below of=c11,node distance = 1.5cm] (c21) {C: b};
  \node [cloud, fill=white, below of=c12,node distance = 3cm] (c32) {D: num};
  \draw[-to,blue,ultra thick](c11) -- (c21);
  \draw [-to,blue,ultra thick] (c21) -- (c11);
  \draw [-to,blue,ultra thick] (c12) -- (c32);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
&
\begin{tikzpicture}[node distance = 3cm, auto]
  \node [cloud, fill=white,node distance = 3cm] (c11) 
  {C: a,{\color{blue} b},{\color{green} num}};
  \node [cloud, fill=white, right of=c11,node distance = 4cm] (c12) {D: a,{\color{green} b},{\color{blue} num}};
  \node [cloud, fill=white, below of=c11,node distance = 1.5cm] (c21) {C: b,{\color{blue} a}};
  \node [cloud, fill=white, below of=c12,node distance = 3cm] (c32) {D: num};
  \draw[-to,blue,ultra thick](c11) -- (c21);
  \draw [-to,blue,ultra thick] (c21) -- (c11);
  \draw [-to,blue,ultra thick] (c12) -- (c32);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
\end{tabularx}
\caption{Une itération de la transformation $\mathcal{T}$ sur un graphe $G_0=SG_0$ (à droite) donnant un supergraphe $SG_1$ (à gauche).}
\label{fig:étape de monomorphisation}
\end{figure}

\begin{mydef} (Supergraph)
Let $G=G_0$ be a dependency and $G_i$ the dependency graph created after $i$ transformation $\mathcal{T}$. The supergraph $SG_i$ of $G_i$ is defined by:
\begin{enumerate}
  \item [-] Nodes are sets composed of a node in the initial graph $G_0$ (head node) and all its derived nodes in $G_i$ (tail nodes). They will be called a supernodes.
  \item [-] {\color{blue}Substitution} undirected links connect two nodes $sn_1$ and $sn_2$ when there is at least one  {\color{blue}substitution} link, between a constant in $sn_1$ and a constant in $sn_2$, in $G_i$.
  \item [-] {\color{green}Binding} undirected links connect two nodes $sn_1$ and $sn_2$ when there is at least one {\color{green}partage} link , between a constant in $sn_1$ and a constant in $sn_2$, in $G_i$.
\end{enumerate}    
\end{mydef}




\begin{mydef} (Redondance) 

Dans un supergraphe, une flèche de substitution est redondante si elle a la m\^eme origine et induit la m\^eme substitution qu'une flèche de substitution à l'intérieur du supernoeud de son origine. A partir de ce moment, nous ne représenterons pas les flèches de substitutions redondantes.
\end{mydef}


\begin{figure}[h!]
\begin{center}
\begin{tikzpicture}[node distance = 3cm, auto]
  % Place nodes
  \node [cloud, fill=white,node distance = 3cm] (c11) 
  {A: a, {\color{red}num}};
  \node [cloud, fill=white, below of=c11,node distance = 1.2cm] (c12) {A: num};
  \draw[-to,blue,ultra thick](c11) to [in=0,out=0] (c12);
  \draw[-to,blue,ultra thick](c11) to [in=40,out=130] (c11);
\end{tikzpicture}
\end{center}
\caption{Supergraph at step 1 with a redundant substitution link. A substitution link inside the super node is exceptionally represented.}
\end{figure}

\begin{thm} (Circuit)

There exists a dependency graph $G$ for which the transformation $\mathcal{T}$ does not find a fix point.
\end{thm}
\begin{proof}(Contre-exemple)

\begin{tabularx}{\textwidth}{ X X }

\noindent \textit{Graphe initial.}
\begin{center}
\begin{tikzpicture}[node distance = 3cm, auto]
  % Place nodes
  \node [cloud, fill=white,node distance = 3cm] (c11) 
  {A: a};
  \node [cloud, fill=white, below of=c11,node distance=1cm] (c12) 
  {A: a $\rightarrow$ n};
  \draw[-to,blue,ultra thick](c11) to [in=0,out=0] (c12);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
\end{center}
&
\noindent \textit{Etape 1.}
\begin{center}
\begin{tikzpicture}[node distance = 3cm, auto]
  % Place nodes
  \node [cloud, fill=white,node distance = 2cm] (c11) 
  {A: a, {\color{red} a $\rightarrow$ n}};
  \node [cloud, fill=white, below of=c11,node distance = 1.2cm] (c12) {A: a $\rightarrow$ n, {\color{red} (a $\rightarrow$ n) $\rightarrow$ n} };
  \draw[-to,blue,ultra thick](c11) to [in=0,out=0] (c12);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
\end{center}
\end{tabularx}

\noindent \textit{Etape 2.}
\begin{center}
\begin{tikzpicture}[node distance = 3cm, auto]
  % Place nodes
  \node [cloud, fill=white,node distance = 1.2cm] (c11) 
  {A: a, 
  {\color{red} a $\rightarrow$ n},
  {\color{orange} (a $\rightarrow$ n) $\rightarrow$ n}
  };
  \node [cloud, fill=white, below of=c11,node distance = 1.2cm] (c12) 
  {A: a $\rightarrow$ n,
  {\color{red} (a $\rightarrow$ n) $\rightarrow$ n},
  {\color{orange} ((a $\rightarrow$ n) $\rightarrow$ n) $\rightarrow$ n}
  };
  \draw[-to,blue,ultra thick](c11) to [in=0,out=0] (c12);
  \draw [green,ultra thick] (c11) -- (c12);
\end{tikzpicture}
\end{center}
La substitution [a $\rightarrow$ (a $\rightarrow$ n)] peut \^etre appliqué autant de fois que l'on veut à a sans trouver de point fixe.
\end{proof}

\begin{conjecture}

Soit $p$ le nombre maximal de substitutions dans les chemins de $G$. Soit $G_p = \mathcal{T}^p(G)$. On conjecture que:
\begin{itemize}
\item Si $SG_p$ n'a pas de circuit interne à ses noeuds et n'a pas de flèches de substitutions non redondantes à l'extérieur de ses noeuds, alors $G_p$ est un point fixe pour $\mathcal{T}$. 
\item Si $G_p$ n'est pas un point fixe pour $\mathcal{T}$, alors pour tout $i>0$, $G_i$ n'est pas un point fixe pour $\mathcal{T}$.
\end{itemize}
\end{conjecture} 

\subsubsection{Extraction des substitutions à partir du graphe de dépendance final}

\par En pratique, pour obtenir le graphe de dépendance final, nous limitons le nombre d'itération de $\mathcal{T}$ en bornant le nombre d'instanciation possibles. Dans {\color{red}142}\% des cas le graphe de dépendance obtenu est un point fixe. [ref interne]
\par Soit $G_i$ le graphe de dépendance obtenu par la méthode décrite dans la partie précédente. De chaque constante du graphe provenant d'un m\^eme théorème du graphe, une liste de subsitutions peut \^etre extraite. Ses listes de substitutions sont combinés de toutes les manières possibles de façon a créer une liste de subsitutions poru ce théorème. Finalement, chaque théorème est instanciée avec sa liste de substitutions. 



