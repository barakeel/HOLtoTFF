\section{Utilisation de \beagle et expériences}
\label{sec:experiences}

\subsection{Présentation de \beagle}
\beagle est un prouveur du premier ordre avec arithmétique très récent,
prenant en entrée le format \tff. Des résultats expérimentaux (sur une
version plus ancienne) ainsi que la théorie détaillée de \beagle peuvent être trouvés dans~\cite{DBLP:conf/cade/BaumgartnerW13}.


\subsection{La tactique \beagletac}
\label{sec:experiences:beagletac}

Grâce à cette traduction, nous avons implanté la tactique \beagletac
exportant le but courant transformé par la traduction présentée dans la
partie précédente au format \tff. \beagle est ensuite appelé sur ce but
transformé; lorsqu'il répond que celui-ci est insatisfiable, il est
ajouté comme axiome à \holfour afin de résoudre le but initial (voir
\textsc{Figure}~\ref{fig:beagletac}).


\subsection{Expériences}
\label{sec:experiences:experiences}

\subsubsection{Software, hardware et tests}
Les tests ont été effectués avec \beagle (version $0.7$) et \holfour (version mai 2013 du dépot \path{https://github.com/mn200/HOL}), sur un processeur deux cœurs cadencé à $2.1$~GHz avec $3.7$~Go de mémoire vive.
Nous avons imposé un timeout de 15 secondes par but à \beagle.

Lors de la construction de \holfour, certains buts sont résolus par la
tactique \metistac. La plupart de ces buts ne font intervenir que du
raisonnement propositionnel, mais certains nécessitent de le combiner
avec un raisonnement arithmétique, auquel cas les lemmes arithmétiques à
utiliser sont fournis à \metistac. Pour les expériences, nous avons
utilisé \beagletac sur $271$ de ces buts, mais sans donner aucun lemme
arithmétique. Afin de mesurer l'impact de notre algorithme de
monomorphisation, nous avons lancé \beagletac avec ou sans
monomorphisation.

\subsubsection{Résultats}

\todo Rendre cette partie cohérente. Il existe un environnement table
(plutôt que figure) pour les tableaux.

\begin{figure}
\centering
\begin{tikzpicture}[scale=1.6,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {80/100*360}
          {80.5\%}{insatisfiable}{green}
    \slice{80.5/100*360}
          {81.5/100*360}
          {1\%}{satisfiable}{red}
    \slice{81.5/100*360}
          {89.5/100*360}
          {8\%}{inconnu, yshift=6}{red}
     \slice{89.5/100*360}
           {98.5/100*360}
           {9\%}{timeout}{red}
     \slice{98.5/100*360}
           {100/100*360}
           {1.5\%}{parsing error}{red}
\end{tikzpicture}
\caption{Nombre de but résolus par \beagletac}
\end{figure}

N'étant pas complet, \beagle peut parfois répondre ``inconnu'' s'il ne
sait pas trouver la solution du problème. En revanche, les
``satisfiable'' (dûs à un manque d'information sur les constantes de
\holfour passées à \beagle) et ``parsing error'' (dûs à un fichier
problème trop grand ou à une erreur dans l'impression) correspondent à
des erreurs dans notre utiliation de \beagle.
\begin{remark}
Comme \beagle ne supporte pas l'arithmétique non linéaire, la constante multiplicative $*$ est traduite par une constante quelconque lorsque le terme est non-linéaire. Cette modification devra être retiré lorsqu'on testera notre traduction avec un prouveur qui supporte l'arithmétique non linéaire.
\end{remark}


\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|X|X|X|}
\hline
  \beagletac & Traduction & Impression & \metistac\\ \hline
  4.55 & 0.82 & 0.18 & 0.11 \\ \hline
\end{tabularx}
\caption{Temps moyen de résolution (en secondes)}
\end{table}


\noindent \textbf{Sur des problèmes d'ordre supérieur}

\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|c|c|c|c|c|}
\hline
$ $ & Problèmes résolus & \beagletac & Traduction & Impression & \metistac \\ \hline
Premier ordre & 170/185 = 91.9\% & 2.711 & 0.148 & 0.08 & 0.13 \\ \hline
Ordre supérieur & 48/86 = 55.8\%  & 11.07 & 3.2 & 0.51 & 0.04 \\ \hline
\end{tabularx}
\caption{Temps moyen de résolution de problème du premier ordre et d'ordre supérieur (en secondes)}
\end{table}
 
\noindent \textbf{Sur des problèmes polymorphes}

\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|c|c|c|c|c|}
\hline
$ $ & Problèmes résolus & \beagletac & Traduction & Impression & \metistac \\ \hline
Monomorphe & 107/132 = 81.1\% & 5.83 & 1.32 & 0.23 & 0.12\\ \hline
Polymorphe & 111/139 = 79.9\%  & 3.32 & 0.34 & 0.13 & 0.9\\ \hline
\end{tabularx}
\caption{Temps moyen de résolution de problèmes monomorphes et polymorphes (en secondes)}
\end{table}

\begin{figure}[H]
Les résultats en termes de nombre de buts résolus sont présentés dans la
\textsc{Figure}~\ref{fig:resultats}.
\noindent \begin{tabularx}{\textwidth}{|X|X|}
\hline
Sans monomorphisation & Avec monomorphisation \\
\hline
\begin{tikzpicture}[scale=1,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {70/100*360}
          {70\%}{insatisfiable}{green}
    \slice{70/100*360}
          {84/100*360}
          {14\%}{satisfiable}{red}
    \slice{84/100*360}
          {91/100*360}
          {7\%}{inconnu}{red}
    \slice{91/100*360}
          {99/100*360}
          {8\%}{timeout}{red}
    \slice{99/100*360}
          {100/100*360}
          {1\%}{parsing error}{red}
\end{tikzpicture}
&
\begin{tikzpicture}[scale=1,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {80/100*360}
          {80.5\%}{insatisfiable}{green}
    \slice{80.5/100*360}
          {81.5/100*360}
          {1\%}{satisfiable}{red}
    \slice{81.5/100*360}
          {89.5/100*360}
          {8\%}{inconnu, yshift=6}{red}
     \slice{89.5/100*360}
           {98.5/100*360}
           {9\%}{timeout}{red}
     \slice{98.5/100*360}
           {100/100*360}
           {1.5\%}{parsing error}{red}
\end{tikzpicture}
\\
\hline
\end{tabularx}
\caption{Impact de la monomorphisation}
\label{fig:resultats}
\end{figure}

On remarque sur la \textsc{Figure}~\ref{fig:resultats} que l'ajout de
l'étape de monomorphisation permet à \beagletac de résoudre $10\%$ de
buts supplémentaires. On constante cependant que cette étape augmente la
taille des buts, faisant ainsi croître le nombre de timeouts. Concernant l'algorithme en lui-même, un point fixe a été trouvé dans 102
cas des 139 problèmes ayant besoin d'être monomorphisés, soit $73\%$ des
cas.

\vspace{1mm}

\noindent \textbf{Sur des problèmes arithmétiques}
\begin{table}[H]
\begin{tabularx}{\textwidth}{|X|c|c|c|c|c|}
\hline
$ $ & Problèmes résolus & \beagletac & Traduction & Impression & \metistac \\ \hline
Non-arithmétique & 89/109 = 81.6\% & 5.91 & 1.51 & 0.25 & 0.08\\ \hline
Arithmétique & 129/162 = 79.6\%  & 3.62 & 0.34 & 0.13 & 0.13\\ \hline
\end{tabularx}
\caption{Temps moyen de résolution de problèmes non-arithmétiques et arithmétiques (en secondes)}
\end{table}




Comme expliqué ci-dessus, parmi les 271 problèmes initialement testés,
nous avons retenu 65 problèmes contenant au moins un lemme arithmétique.
Alors que \metistac a besoin de ce lemme pour résoudre le but,
\beagletac y parvient dans $88\%$ des cas sans l'aide d'aucun lemme.
\beagletac permet donc de résoudre des problèmes combinant d'ordre
supérieur avec arithmétique, lorsque le raisonnement propositionnel est
du premier ordre. Cette tactique est donc plus expressive que \metistac,
et fournit la première tactique \holfour capable de combiner
raisonnement au premier ordre et arithmétique.

\paragraph {Conclusion sur \beagletac}.
En résumé, \beagletac est bien moins rapide que \metistac. Ce qui est en partie dû au temps d'ouverture et de fermeture de fichier ainsi qu'au temps de lancement de java. \beagletac résout bien moins bien les problèmes d'ordres supérieur.

\paragraph {Améliorations possibles de la traduction}
- Faire une élimination plus fine de l'ordre supérieur ~\cite{Bohme12}
- Inférer des lemmes utiles pour le problème à partir d'une heuristique sur les constantes \cite{Paulson10,KaliszykU12}.
- Traduire les types rationnels et réels de \holfour vers les types \tff correspondants.

