\section{Utilisation de \beagle et expériences}
\label{sec:experiences}

\subsection{Présentation de \beagle}
\beagle est un prouveur du premier ordre avec arithmétique très récent,
prenant en entrée le format \tff. Des résultats expérimentaux (sur une
version plus ancienne) ainsi que la théorie détaillée de \beagle peuvent être trouvés dans~\cite{DBLP:conf/cade/BaumgartnerW13}.


\subsection{La tactique \beagletac}
\label{sec:experiences:beagletac}



\subsection{Expériences}
\label{sec:experiences:experiences}

\subsubsection{Software, hardware et tests}
Les tests ont été effectués avec \beagle (version $0.7$) et \holfour (version mai 2013 du dépot \path{https://github.com/mn200/HOL}), sur un processeur deux cœurs cadencé à $2.1$~GHz avec $3.7$~Go de mémoire vive. 
Nous avons imposé un time out de 15 secondes par but à \beagle.
 
Lors de la construction de \holfour, certains buts sont résolus par la
tactique \metistac. La plupart de ces buts ne font intervenir que du
raisonnement propositionnel, mais certains nécessitent de le combiner
avec un raisonnement arithmétique, auquel cas les lemmes arithmétiques à
utiliser sont fournis à \metistac. Pour les expériences, nous avons
utilisé \beagletac sur $271$ de ces buts, sans donner aucun lemme
arithmétique.


\subsubsection{Résultats}


\subsubsection{Expressivité et efficacité de \beagletac et \beagle. Comparaison avec \metistac}
\paragraph {Dans le cas général}

Les résultats inconnu et satisfiable sont dûs à un manque d'information sur les constantes de HOL4 passées à Beagle. Le résultat time out est dû à un surplus d'information où à une complexité du problème trop grande.
Le résultat parsing error est peut-être dû à un fichier problème trop grand (plus de 1000 lignes) ou à une erreur dans l'impression.

\paragraph {Sur des problèmes de l'ordre supérieur}

\paragraph {Sur les problèmes polymorphes}
Voici dans la figure 4, l'impact absolu qu'à la monomorphisation sur le nombre de problèmes résolus.
\begin{figure}
\noindent \begin{tabularx}{\textwidth}{|X|X|}
\hline
Avant monomorphisation & Après monomorphisation \\
\hline
\begin{tikzpicture}[scale=1.5,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {70/100*360}
          {70\%}{insatisfiable}{green}
    \slice{70/100*360}
          {84/100*360}
          {14\%}{satisfiable}{red}      
    \slice{84/100*360}
          {91/100*360}
          {7\%}{inconnu}{red}
    \slice{91/100*360}
          {99/100*360}
          {8\%}{time out}{red}
    \slice{99/100*360}
          {100/100*360}
          {1\%}{parsing error}{red}                            
\end{tikzpicture}
&
\begin{tikzpicture}[scale=1.5,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {80/100*360}
          {80\%}{insatisfiable}{green}
    \slice{80/100*360}
          {81/100*360}
          {1\%}{satisfiable}{red}  
    \slice{81/100*360}
          {86/100*360}
          {5\%}{inconnu, yshift=6}{red}   
     \slice{86/100*360}
           {98/100*360}
           {12\%}{time out}{red}     
     \slice{98/100*360}
           {100/100*360}
           {2\%}{parsing error}{red}               
\end{tikzpicture}
\\
\hline
\end{tabularx}
\caption{Impact absolu de la monomorphisation}
\end{figure}

D'un point de vue théorique, l'étape de monomorphisation est efficace car un point fixe est trouvé dans 112 cas sur 139 problèmes ayant besoin d'être monomorphisé.
D'un point de vue pratique, on remarque que l'ajout de l'étape de monomorphisation améliore l'expressivité de \beagletac en agrandissant l'espace de recherche augmentant le nombre de résultat insatisfiable et minimisant le nombre de résultats inconnus ou satisfiable. Cependant l'efficacité en pâtit comme nous le montre l'augmentation des time out.


\paragraph {Sur des problèmes arithmétiques}
Pour montrer, la plus grande expressivité de \beagletac par rapport à \metistac en arithmétique nous avons effectué le test suivant:
\\Parmi les 271 problèmes initialement testés, nous avons retenu 65 problèmes contenant au moins un lemme arithmétique et nous avons supprimés 79 tels lemmes. \metistac n'est donc plus en mesure de résoudre l'un de ses problèmes modifiés. Cependant \beagletac y parvient dans 88\% des cas car il possède par construction un ensemble de connaissance sur l'arithmétique linéaire.
\\Grâce à notre traduction, \beagletac permet de résoudre des problèmes
combinant d'ordre supérieur avec arithmétique, lorsque le raisonnement
propositionnel est du premier ordre. Cette tactique est donc plus
expressive que \metistac, puisqu'il n'est pas besoin de fournir les
lemmes arithmétiques utilisés.

