\section{Utilisation de \beagle et expériences}
\label{sec:experiences}

\subsection{Présentation de \beagle}
\beagle est un prouveur du premier ordre avec arithmétique très récent,
prenant en entrée le format \tff. Des résultats expérimentaux (sur une
version plus ancienne) ainsi que la théorie détaillée de \beagle peuvent être trouvés dans~\cite{DBLP:conf/cade/BaumgartnerW13}.


\subsection{La tactique \beagletac}
\label{sec:experiences:beagletac}

Grâce à cette traduction, nous avons implanté la tactique \beagletac
exportant le but courant transformé par la traduction présentée dans la
partie précédente au format \tff. \beagle est ensuite appelé sur ce but
transformé; lorsqu'il répond que celui-ci est insatisfiable, il est
ajouté comme axiome à \holfour afin de résoudre le but initial (voir
\textsc{Figure}~\ref{fig:beagletac}).


\subsection{Expériences}
\label{sec:experiences:experiences}

\subsubsection{Software, hardware et tests}
Les tests ont été effectués avec \beagle (version $0.7$) et \holfour (version mai 2013 du dépot \path{https://github.com/mn200/HOL}), sur un processeur deux cœurs cadencé à $2.1$~GHz avec $3.7$~Go de mémoire vive.
Nous avons imposé un timeout de 15 secondes par but à \beagle.

Lors de la construction de \holfour, certains buts sont résolus par la
tactique \metistac. La plupart de ces buts ne font intervenir que du
raisonnement propositionnel, mais certains nécessitent de le combiner
avec un raisonnement arithmétique, auquel cas les lemmes arithmétiques à
utiliser sont fournis à \metistac. Pour les expériences, nous avons
utilisé \beagletac sur $271$ de ces buts, mais sans donner aucun lemme
arithmétique. Afin de mesurer l'impact de notre algorithme de
monomorphisation, nous avons lancé \beagletac avec ou sans
monomorphisation.



\subsubsection{Résultats}

\textbf{Dans le cas général}

\begin{figure}
\begin{tabularx}{\textwidth}{|X|X|X|X|X|X|}
\hline
Nombre de problèmes & insatisfiable & satisfiable & unknown & time out & parsing error\\
\hline
Nombre de problèmes & insatisfiable & satisfiable & unknown & time out & parsing error\\
\hline
\end{tabularx}
\caption{Expressivité général de \beagletac sur des problèmes résolus par \metistac}
\end{figure}
\beagletac a résolu 80.4\% des 271 problèmes proposés. Nous avons donc testés la vitesse de  \metistac et de \beagletac sur ces 218 problèmes.

\begin{figure}
\begin{tabularx}{\textwidth}{|X|X|X|X|X|}
\hline
  & \metistac  & \beagletac & Traduction & Impression\\
\hline
Temps moyen (secondes) & 0.11 & 4.55 & 0.82 & 0.18 \\
\hline
\end{tabularx}
\caption{Temps moyen mis par \metistac, \beagletac et les étapes de \beagletac interne à \holfour.}
\end{figure}

Les résultats inconnu et satisfiable sont dûs à un manque d'information sur les constantes de HOL4 passées à Beagle. Le résultat time out est dû à un surplus d'information où à une complexité du problème trop grande.
Le résultat parsing error est dû à un fichier problème trop grand (plus de 1000 lignes), les problèmes de ce type ont été testé sur d'autres prouveur sans erreur de parsing.

\noindent \textbf{Sur des problèmes de l'ordre supérieur:}

\noindent \begin{tabularx}{\textwidth}{|X|X|X|}
\hline
$ $ & Premier ordre & Ordre supérieur \\ \hline
Problèmes résolus & 170/185 = 91.9\% & 48/86 = 55.8\% \\\hline
\end{tabularx}

\begin{figure}[h!]
\begin{tabularx}{\textwidth}{|c|X|X|X|X|}
\hline
$ $ & \metistac  & \beagletac & Traduction & Impression\\ \hline
Premier ordre & 0.11 & 4.55 & 0.82 & 0.18 \\ \hline
Ordre supérieur  & 0.11 & 4.55 & 0.82 & 0.18 \\ \hline
\end{tabularx}
\caption{Temps moyen (en secondes) mis par les différentes fonctions sur des problèmes du premier ordre et d'ordre supérieur.}
\end{figure}


\textbf{Sur les problèmes polymorphes}

\noindent \begin{tabularx}{\textwidth}{|X|X|X|}
\hline
$ $ & Monomorphes & Polymorphes \\ \hline
Problèmes résolus & 107/132 = 81.1\% & 111/139 = 79.9\% \\\hline
\end{tabularx}

\begin{figure}[h!]
\begin{tabularx}{\textwidth}{|c|X|X|X|X|}
\hline
$ $ & \metistac  & \beagletac & Traduction & Impression\\ \hline
Premier ordre & 0.11 & 4.55 & 0.82 & 0.18 \\ \hline
Ordre supérieur  & 0.11 & 4.55 & 0.82 & 0.18 \\ \hline
\end{tabularx}
\caption{Temps moyen (en secondes) mis par les différentes fonctions sur des problèmes du premier ordre et d'ordre supérieur.}
\end{figure}

Nous avons retranché l'étape de monomorphisation pour calculer l'impact absolu de la monomorphisation présentés dans la figure ... . 


\begin{figure}[!h]
Les résultats en termes de nombre de buts résolus sont présentés dans la
\textsc{Figure}~\ref{fig:resultats}.
\noindent \begin{tabularx}{\textwidth}{|X|X|}
\hline
Sans monomorphisation & Avec monomorphisation \\
\hline
\begin{tikzpicture}[scale=1,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {70/100*360}
          {70\%}{insatisfiable}{green}
    \slice{70/100*360}
          {84/100*360}
          {14\%}{satisfiable}{red}
    \slice{84/100*360}
          {91/100*360}
          {7\%}{inconnu}{red}
    \slice{91/100*360}
          {99/100*360}
          {8\%}{timeout}{red}
    \slice{99/100*360}
          {100/100*360}
          {1\%}{parsing error}{red}
\end{tikzpicture}
&
\begin{tikzpicture}[scale=1,baseline=(current bounding box.center)]
    \slice{0/100*360}
          {80/100*360}
          {80\%}{insatisfiable}{green}
    \slice{80/100*360}
          {81/100*360}
          {1\%}{satisfiable}{red}
    \slice{81/100*360}
          {86/100*360}
          {5\%}{inconnu, yshift=6}{red}
     \slice{86/100*360}
           {98/100*360}
           {12\%}{timeout}{red}
     \slice{98/100*360}
           {100/100*360}
           {2\%}{parsing error}{red}
\end{tikzpicture}
\\
\hline
\end{tabularx}
\caption{Nombre de buts résolus et impact de la monomorphisation}
\label{fig:resultats}
\end{figure}
<<<<<<< HEAD
D'un point de vue théorique, l'étape de monomorphisation est efficace car un point fixe est trouvé dans 102 cas sur 139 problèmes ayant besoin d'être monomorphisé. 
D'un point de vue pratique, on remarque que l'ajout de l'étape de monomorphisation améliore l'expressivité de \beagletac en agrandissant l'espace de recherche augmentant le nombre de résultat insatisfiable et minimisant le nombre de résultats inconnus ou satisfiable. Cependant l'efficacité en pâtit comme nous le montre l'augmentation des time out.
=======

N'étant pas complet, \beagle peut parfois répondre ``inconnu'' s'il ne
sait pas trouver la solution du problème. En revanche, les
``satisfiable'' (dûs à un manque d'information sur les constantes de
\holfour passées à \beagle) et ``parsing error'' (dûs à un fichier
problème trop grand ou à une erreur dans l'impression) correspondent à
des erreurs dans notre utiliation de \beagle.


\paragraph {Sur les problèmes d'ordre supérieur}

\todo


\paragraph {Sur les problèmes polymorphes}
On remarque sur la \textsc{Figure}~\ref{fig:resultats} que l'ajout de
l'étape de monomorphisation permet à \beagletac de résoudre $10\%$ de
buts supplémentaires. On constante cependant que cette étape augmente la
taille des buts, faisant ainsi croître le nombre de timeouts.

Concernant l'algorithme en lui-même, un point fixe a été trouvé dans 112
cas des 139 problèmes ayant besoin d'être monomorphisés, soit $81\%$ des
cas.


\paragraph {Sur les problèmes arithmétiques}
Comme expliqué ci-dessus, parmi les 271 problèmes initialement testés,
nous avons retenu 65 problèmes contenant au moins un lemme arithmétique.
Alors que \metistac a besoin de ce lemme pour résoudre le but,
\beagletac y parvient dans $88\%$ des cas sans l'aide d'aucun lemme.
\beagletac permet donc de résoudre des problèmes combinant d'ordre
supérieur avec arithmétique, lorsque le raisonnement propositionnel est
du premier ordre. Cette tactique est donc plus expressive que \metistac,
et fournit la première tactique \holfour capable de combiner
raisonnement au premier ordre et arithmétique.


\textbf{Sur des problèmes arithmétiques}

\noindent \begin{tabularx}{\textwidth}{|X|X|X|}
\hline
$ $ & Non-arithmétiques & Arithmétiques \\ \hline
Problèmes résolus & 89/109 = 81.6\% & 129/162 = 79.6\% \\\hline
\end{tabularx}



Pour montrer, la plus grande expressivité de \beagletac par rapport à \metistac en arithmétique nous avons effectué le test suivant:
\\Parmi les 271 problèmes initialement testés, nous avons retenu 65 problèmes contenant au moins un lemme arithmétique et nous avons supprimés 79 tels lemmes. \metistac n'est donc plus en mesure de résoudre l'un de ses problèmes modifiés. Cependant \beagletac y parvient dans 88\% des cas car il possède par construction un ensemble de connaissance sur l'arithmétique linéaire.
\\Grâce à notre traduction, \beagletac permet de résoudre des problèmes
combinant d'ordre supérieur avec arithmétique, lorsque le raisonnement
propositionnel est du premier ordre. Cette tactique est donc plus
expressive que \metistac, puisqu'il n'est pas besoin de fournir les
lemmes arithmétiques utilisés.
=======
>>>>>>> 30b154a18989504800d2692fd39f2538eb6e6e90





\paragraph {Ce que cela nous apprend sur \beagletac}.
En résumé \beagletac est bien moins rapide que \metistac. En outre l'ouverture et la fermeture de fichier ainsi que l'ouverture de java. Même le temps de traduction est supérieur à celui mis par \metistac pour trouver la solution. Bien que cette étude n'ait pas été centralisé sur l'efficacité de \beagle
