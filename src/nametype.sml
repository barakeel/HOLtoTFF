structure nametype :> nametype =
struct
(*
load "listtools"; open listtools;
load "stringtools"; open stringtools;
load "mydatatype"; open mydatatype;
load "extractvar"; open extractvar;
load "extracttype"; open extracttype;
*)
open HolKernel numSyntax 
     stringtools listtools mydatatype 
     extractvar extracttype 
   

fun NAMETYPE_ERR function message =
  HOL_ERR {origin_structure = "nametype",
           origin_function = function,
           message = message}


(* should add compound type like int list*)  
fun name_type ty = 
  case typecat ty of
    Booltype => fst (dest_type ty)
  | Numtype => fst (dest_type ty)
  | Alphatype => String.substring 
                 (dest_vartype ty,1,
                  String.size (dest_vartype ty) - 1 ) 
  | Leaftype => fst (dest_type ty)
  | Funtype => raise NAMETYPE_ERR "name_type" "funtype"
  | Prodtype => raise NAMETYPE_ERR "name_type" "prodtype"

fun name_tff_type ty = 
  let val name = name_type ty in 
    if is_alphanumor_ name
    then "ty_" ^ name
    else "ty_"
  end


fun name_simplety ty = 
  case typecat ty of
    Booltype => name_tff_type ty
  | Numtype => name_tff_type ty
  | Alphatype => name_tff_type ty
  | Leaftype => name_tff_type ty
  | Funtype => let val (str,l) = dest_type ty in
               let 
                 val ty1 = hd l
                 val ty2 = hd (tl l)
               in 
                 "p_" ^ (name_simplety ty1) ^ 
                 "_fun_" ^ (name_simplety ty2) ^ "_p" 
               end end  
  | Prodtype => let val (str,l) = dest_type ty in         
                let 
                  val ty1 = hd l
                  val ty2 = hd (tl l)
                in 
                  "p_" ^ (name_simplety ty1) ^ 
                  "_prod_" ^ (name_simplety ty2) ^ "_p"
                end end  

(* add add for a simpletype *) (* tyadict should already contain alphatydict *)
(* Booltype is an exception *) 
(* we should consider if he's found as an argument of a function *)
(* has to be found when extracting the variable *)
(* quantification over boolean is not good either *)


(* should add the axioms for boolean before if we encounter one boolean arg *)
(*
btrue : bool
bfalse : bool
/\ !x:bool x=xtrue or x=xfalse
*)

(* tyadict *)
fun add_simpletya (ty,arity) tyadict =
  if arity <> 0 then
    raise NAMETYPE_ERR "add_simpletya" "not a simpletype"
  else
    let val n = length tyadict in
      case typecat ty of
        Booltype => let val str = "$o" in
                      add_entry ((ty,0),str) tyadict
                    end 
      | Numtype => let val str = "$int" in
                     add_entry ((ty,0),str) tyadict
                   end
      | _ => let val str = name_simplety ty in
               addrenamel [((ty,0),str)] tyadict
             end 
    end   

fun add_simpletyal key dict = repeatchange add_simpletya key dict

(* add other simple types generated by a compound type, i.e. : 
   if (int -> int -> bool, 1) is a type used 
   then add (int,0) and (int -> bool,0)  *)
fun add_innersimpletya (ty,arity) tyadict =
  let val (argl,image) = dest_type_nb (ty,arity) in
  let val tyal = image :: argl in 
    add_simpletyal tyal tyadict
  end end
  
fun add_innersimpletyal key dict = repeatchange add_innersimpletya key dict

fun name_tyargl argl tyadict =
  case argl of
    [] => raise NAMETYPE_ERR "name_tyargl" "no arguments"
  | [(ty,arity)] => lookup (ty,arity) tyadict  
  | (ty,arity) :: m => (lookup (ty,arity) tyadict) ^ " * " ^
                       (name_tyargl m tyadict)
                       
fun name_compoundty (argl,image) tyadict = 
  case argl of
    [] => lookup image tyadict
  | [(ty,arity)] => (lookup (ty,arity) tyadict) ^ " > " ^
                    (lookup image tyadict)
  | _ => "( " ^ (name_tyargl argl tyadict) ^ " )" ^ " > " ^
         (lookup image tyadict)

(* add his own type *)
fun add_compoundtya (ty,arity) tyadict =
   let val (argl,image) = dest_type_nb (ty,arity) in
   let val str = name_compoundty (argl,image) tyadict in
     add_entry ((ty,arity),str) tyadict  
   end end

fun add_compoundtyal key dict = repeatchange add_compoundtya key dict

(* lowest arity plays an important role here *)
fun create_tyadict term =
  let val tyal = all_tya term in 
  let 
    val simpletyal = get_simpletyal tyal
    val compoundtyal = get_compoundtyal tyal 
  in
  let val simpletyadict = add_simpletyal simpletyal [] in
  let val newsimpletyadict = add_innersimpletyal compoundtyal simpletyadict in  
  let val tyadict = add_compoundtyal compoundtyal newsimpletyadict in
    tyadict
  end end end end end 



end
  
