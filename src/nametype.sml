structure nametype :> nametype =
struct

open HolKernel extractvar extracttype stringtools listtools mydatatype numSyntax 

fun NAMETYPE_ERR function message =
  HOL_ERR{origin_structure = "nametype",
          origin_function = function,
          message = message}

(* INDICATIVE NAME *)
(* this is only used as an indicative name *)
fun indname2 ty = 
  case typecat ty of
    Booltype => fst (dest_type ty)
  | Numtype => fst (dest_type ty)
  | Alphatype => String.substring (dest_vartype ty,1,1) (* not good *)
  | Leaftype => fst (dest_type ty)
  | Funtype => raise NAMETYPE_ERR "holindname" "funtype"
  | Prodtype => raise NAMETYPE_ERR "holindname" "prodtype"

fun indname ty =
  let val str = indname2 ty in
    if isalphanumor_ str 
    then str   
    else "unprintable"
  end              

fun indicativename ty = 
  case typecat ty of
    Booltype => indname ty
  | Numtype => indname ty
  | Alphatype => indname ty
  | Leaftype => indname ty
  | Funtype => let val (str,l) = dest_type ty in
               let 
                 val ty1 = hd l
                 val ty2 = hd (tl l)
               in 
                 "p_" ^ (indicativename ty1) ^ 
                 "_fun_" ^ (indicativename ty2) ^ "_p" 
               end end  
  | Prodtype => let val (str,l) = dest_type ty in         
                let 
                  val ty1 = hd l
                  val ty2 = hd (tl l)
                in 
                  "p_" ^ (indicativename ty1) ^ 
                  "_prod_" ^ (indicativename ty2) ^ "_p"
                end end  
(* END OF INDICATIVE NAME *)


(* add add for a simpletype *) (* tydict should already contain alphatynm *)

fun addsimpletype (ty,narg) tydict =
  if narg <> 0 then
    raise NAMETYPE_ERR "addsimpletype" "not a simpletype"
  else
    let val n = length tydict in
      case typecat ty of
        Booltype => let val str = "$o" in
                      addentry ((ty,0),str) tydict
                    end 
      | Numtype => let val str = "$int" in
                     addentry ((ty,0),str) tydict
                   end
      | _ => let val str = (namestrn "ty" n) ^ (indicativename ty) in
               addentry ((ty,0),str) tydict
             end 
    end   

(* on a simpletype list *)
fun addsimpletypel ty_narg tydict =
  case ty_narg of
    [] => tydict
  | (ty,narg) :: m => addsimpletypel m (addsimpletype (ty,narg) tydict) 


(* on leafvtypel result *) (* tydict should already contain alphatynm *)
fun addleafvtypel ty_narg tydict =  
  case ty_narg of
    [] => tydict
  | (ty,0) :: m => addleafvtypel m (addsimpletype (ty,0) tydict)
  | _ => raise NAMETYPE_ERR "addleafvtype" "not a simpletype"


(* add other simpletype generated by a nodevar 
   i.e. : if f has type (int -> int -> bool, 1) then
   add (int,0) and (int -> bool,0)  *)
fun addnodevsimpletype (ty,narg) tydict =
  let val (argl,image) = desttypenb (ty,narg) in
  let val ty_narg = image :: argl in 
    addsimpletypel ty_narg tydict
  end end

(* on nodevtypel result *)
fun addnodevsimpletypel ty_narg tydict =
  case ty_narg of
    [] => tydict
 | (ty,narg) :: m => addnodevsimpletypel m (addnodevsimpletype (ty,narg) tydict) 

(* when all the simple types are tydict *)
fun nameargl ty_narg tydict = 
  case ty_narg of
    [] => ""
  | [(ty,narg)] => lookup (ty,narg) tydict  
  | (ty,narg) :: m => (lookup (ty,narg) tydict) ^ " * " ^ (nameargl m tydict)

fun namecompoundtype (argl,image) tydict = 
  case argl of
    [] => lookup image tydict
  | [(ty,narg)] => (lookup (ty,narg) tydict) ^ " > " ^ (lookup image tydict)
  | _ => "( " ^ (nameargl argl tydict) ^ " )" ^ " > " ^ (lookup image tydict)

(* add his own type *)
fun addnodevtype (ty,narg) tydict =
   let val (argl,image) = desttypenb (ty,narg) in
   let val str = namecompoundtype (argl,image) tydict in
     addentry ((ty,narg),str) tydict  
   end end

(* on nodevtypel result *) (* 3rd time doing the same kind of code (generalize or not) *)
fun addnodevtypel ty_narg tydict =
  case ty_narg of
    [] => tydict
  | (ty,narg) :: m => addnodevtypel m (addnodevtype (ty,narg) tydict) 



end
  
