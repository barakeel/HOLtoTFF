structure nametype :> nametype =
struct


open HolKernel numSyntax 
     extractvar extracttype stringtools 
     listtools mydatatype 
         
fun NAMETYPE_ERR function message =
  HOL_ERR{origin_structure = "nametype",
          origin_function = function,
          message = message}

(* tools *)
fun repeatchange change l changing = 
  case l of
    [] => changing
  | a :: m => repeatchange change m (change a changing)

(* should add compound type like int list*)  
fun name_type ty = 
  case typecat ty of
    Booltype => fst (dest_type ty)
  | Numtype => fst (dest_type ty)
  | Alphatype => String.substring 
                 (dest_vartype ty,1,
                  String.size (dest_vartype ty) - 1 ) 
  | Leaftype => fst (dest_type ty)
  | Funtype => raise NAMETYPE_ERR "name_type" "funtype"
  | Prodtype => raise NAMETYPE_ERR "name_type" "prodtype"

fun name_tff_type ty = 
  let val name = name_type ty in 
    if is_alphanumor_ name
    then "ty_" ^ name
    else "ty_"
  end


fun name_simplety ty = 
  case typecat ty of
    Booltype => name_tff_type ty
  | Numtype => name_tff_type ty
  | Alphatype => name_tff_type ty
  | Leaftype => name_tff_type ty
  | Funtype => let val (str,l) = dest_type ty in
               let 
                 val ty1 = hd l
                 val ty2 = hd (tl l)
               in 
                 "p_" ^ (name_simplety ty1) ^ 
                 "_fun_" ^ (name_simplety ty2) ^ "_p" 
               end end  
  | Prodtype => let val (str,l) = dest_type ty in         
                let 
                  val ty1 = hd l
                  val ty2 = hd (tl l)
                in 
                  "p_" ^ (name_simplety ty1) ^ 
                  "_prod_" ^ (name_simplety ty2) ^ "_p"
                end end  

(* add add for a simpletype *) (* tyadict should already contain alphatydict *)
(* Booltype is an exception *) 
(* we should consider if he's found as an argument of a function *)
(* has to be found when extracting the variable *)
(* quantification over boolean is not good either *)


(* should add the axioms for boolean before if we encounter one boolean arg *)
(*
btrue : bool
bfalse : bool
/\ !x:bool x=xtrue or x=xfalse
*)


(* tyadict *)
fun add_simpletya (ty,arity) tyadict =
  if arity <> 0 then
    raise NAMETYPE_ERR "add_simpletya" "not a simpletype"
  else
    let val n = length tyadict in
      case typecat ty of
        Booltype => let val str = "$o" in
                      add_entry ((ty,0),str) tyadict
                    end 
      | Numtype => let val str = "$int" in
                     add_entry ((ty,0),str) tyadict
                   end
      | _ => let val str = name_new (name_simplety ty) tyadict in
               add_entry ((ty,0),str) tyadict
             end 
    end   

fun add_simpletyal = repeatchange add_simpletya 

(* add other simple types generated by a compound type, i.e. : 
   if (int -> int -> bool, 1) is a type used 
   then add (int,0) and (int -> bool,0)  *)
fun add_innersimpletya (ty,arity) tyadict =
  let val (argl,image) = dest_type_nb (ty,arity) in
  let val tyal = image :: argl in 
    add_simpletyal tyal tyadict
  end end

fun add_innersimpletyal = repeatchange add_innersimpletya 

(* when all the simple types are in tyadict *)
fun name_tyargl tyal tyadict = 
  case tyal of
    [] => ""
  | [(ty,arity)] => lookup (ty,arity) tyadict  
  | (ty,arity) :: m => (lookup (ty,arity) tyadict) ^ " * " ^ (name_tyargl m tyadict)

fun name_compoundty (argl,image) tyadict = 
  case argl of
    [] => lookup image tyadict
  | [(ty,arity)] => (lookup (ty,arity) tyadict) ^ " > " ^ (lookup image tyadict)
  | _ => "( " ^ (name_tyargl argl tyadict) ^ " )" ^ " > " ^ (lookup image tyadict)

(* add his own type *)
fun add_compoundtya (ty,arity) tyadict =
   let val (argl,image) = dest_type_nb (ty,arity) in
   let val str = name_compoundty (argl,image) tyadict in
     add_entry ((ty,arity),str) tyadict  
   end end

fun add_compoundtyal = repeatchange add_compoundtya

(* lowest arity plays an important role here *)
fun create_tyadict term =
  let val tyal = collapse_lowestarity (all_tya term) in 
  let 
   val simpletyal = get_simpletyal tyal
   val compoundtyal = get_compoundtyal tyal 
  in
  let val simpletyadict = add_simpletyal simpletyal [] in
  let val newsimpletyadict = add_innersimpletyal compoundtyal simpletyadict in  
  let val tyadict = add_compoundtyal compoundtyal newsimpletyadict in
    tyadict
  end end end end end 



end
  
