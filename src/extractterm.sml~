structure extractterm :> extractterm =
struct

open HolKernel listtools mydatatype

fun EXTRACTTERM_ERR function message =
  HOL_ERR{origin_structure = "extractterm",
          origin_function = function,
          message = message}

(*warning: should have the same structure as printterm in printtff.sml*)
(* test if a variable has second order then  *)
(* try to replace this by find_terms but the problem is boundvar*)
(* function info *)
datatype TREE = Empty | (Node of string) * (TREE list) | (Leaf of string)  



(* traverse *)
(* complexity quadratic on the number of variables *)
fun classifyvc term bvl =
  case termstructure term of
    Numeral => [(term, [Leaf of "numeral"])] 
  | Var => if ismember term bvl
           then [(term, [Leaf of "bv"])] 
           else [(term, [Leaf of "fv"])] 
  | Const => case leafconst term of
             (
               True => [(term, [Leaf of "dc"])]
             | False => [(term, [Leaf of "dc"])]
             | Newleafconst => [(term, [Leaf of "dc"])]
             )
  | Comb => (
            case connective term of
              Conj => classifyvcbinop term bvl
            | Disj => classifyvcbinop term bvl
            | Neg => classifyvcunop term bvl
            | Imp_only => classifyvcbinop term bvl
            | Forall => let val (qbvl,t) = strip_forall term in
                          classifyvc t (qbvl @ bvl)
                        end       
            | Exists => let val (qbvl,t) = strip_exists term in
                          classifyvc t (qbvl @ bvl) 
                        end
            | App => let val (operator,argl) = strip_comb term in
                     let val l = classifyvcl2 argl bvl in
                       case termstructure operator of
                         Numeral => raise EXTRACTTERM_ERR "printterm" "operator is numeral"
                       | Var =>  if ismember term bvl
                                 then [(operator,"nodebv")] :: l 
                                 else [(operator,"nodefv")] :: l 
                       | Const => (
                                  case nodeconst term of
                                    Newnodeconst => [(operator,"nodec")] :: l    
                                  | _ => [(operator,"nodedc")] :: l 
                                  )
                       | Comb => raise EXTRACTTERM_ERR "printterm" "operator is comb"
                       | Abs => raise EXTRACTTERM_ERR "printterm" "abstraction"
                     end end
             )
  | Abs => raise EXTRACTTERM_ERR "printterm" "abstraction"
and classifyvcl2 list bvl = 
  case list of
    [] => raise EXTRACTTERM_ERR "printterml" "emptylist"
  | [t] => classifyvc t bvl
  | t :: m => (classifyvc t bvl) @ (classifyvcl2 m bvl)
and classifyvcunop term bvl =
  let val (operator,l) = strip_comb term in
  let val lhs = hd l in
    classifyvc lhs bvl
  end end
and classifyvcbinop term bvl = 
  let val (operator,l) = strip_comb term in
  let 
    val lhs = hd l
    val rhs = hd (tl l) 
  in
    (classifyvc lhs bvl) @ (classifyvc rhs bvl) 
  end end

fun classifyvcl termlist = erasedouble (classifyvcl2 termlist [])


fun infertype =






end
